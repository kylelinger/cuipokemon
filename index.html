<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokemon Yellow Remake (Canvas)</title>
    <style>
        @font-face {
            font-family: 'PixelFont';
            src: url('https://cdnjs.cloudflare.com/ajax/libs/vt323/1.3.0/VT323-Regular.ttf'); /* Fallback or use a system font that looks pixelated */
        }

        body {
            background-color: #202020;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 480px;
            height: 432px; /* 160x144 * 3 */
            background-color: #9bbc0f; /* Gameboy green-ish */
            border: 10px solid #505050;
            border-radius: 10px 10px 40px 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls-hint {
            margin-top: 20px;
            text-align: center;
            color: #aaa;
            font-size: 14px;
        }

        .key {
            background: #444;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #666;
            color: #fff;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="160" height="144"></canvas>
    </div>

    <div class="controls-hint">
        <p>控制: <span class="key">方向键</span> 移动</p>
        <p><span class="key">Z</span> 确定 (A) | <span class="key">X</span> 取消 (B)</p>
    </div>

<script>
/**
 * POKEMON YELLOW WEB REMAKE
 * Core Logic & Engine
 */

// --- Constants & Config ---
const TILE_SIZE = 16;
const SCREEN_WIDTH = 160;
const SCREEN_HEIGHT = 144;
const FPS = 60;
const MOVE_SPEED = 2; // Pixels per frame

// Colors (Gameboy Palette)
const PALETTE = {
    white: "#e0f8cf",
    light: "#86c06c",
    dark: "#306850",
    black: "#071821"
};

// Keys
const KEYS = {
    UP: 'ArrowUp',
    DOWN: 'ArrowDown',
    LEFT: 'ArrowLeft',
    RIGHT: 'ArrowRight',
    A: 'z',
    B: 'x'
};

// Map Codes
const TILE = {
    WALK: 0,
    WALL: 1,
    GRASS: 2,
    DOOR: 3
};

// --- Assets (Procedural Pixel Art) ---
// Simple 16x16 sprites represented by drawing commands or simple arrays
const Sprites = {
    player: {
        color: "#ff0000",
        // Simple representation: Head, Body
        draw: (ctx, x, y, frame, dir) => {
            ctx.fillStyle = PALETTE.black;
            // Shadow/Outline
            ctx.fillRect(x+2, y+14, 12, 2);
            
            // Body (Red)
            ctx.fillStyle = "#FF3333";
            ctx.fillRect(x+4, y+6, 8, 8);
            
            // Hat (White/Red)
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(x+4, y+2, 8, 2);
            ctx.fillStyle = "#FF0000";
            ctx.fillRect(x+4, y+4, 8, 2);
            
            // Legs (animation)
            ctx.fillStyle = PALETTE.black;
            if (frame % 20 < 10) {
                 ctx.fillRect(x+4, y+14, 3, 2);
                 ctx.fillRect(x+9, y+14, 3, 2);
            } else {
                 ctx.fillRect(x+5, y+14, 3, 2);
                 ctx.fillRect(x+8, y+14, 3, 2);
            }
        }
    },
    pikachu: {
        color: "#ffcc00",
        draw: (ctx, x, y, frame, dir) => {
             // Tail
            ctx.fillStyle = "#663300";
            ctx.fillRect(x+10, y+4, 4, 2);
            ctx.fillStyle = "#FFCC00"; 
            ctx.fillRect(x+10, y+6, 2, 4);

            // Body
            ctx.fillStyle = "#FFCC00";
            ctx.fillRect(x+3, y+6, 10, 8);
            
            // Ears
            ctx.fillStyle = "#000"; // Tips
            ctx.fillRect(x+3, y+2, 2, 2);
            ctx.fillRect(x+11, y+2, 2, 2);
            ctx.fillStyle = "#FFCC00";
            ctx.fillRect(x+3, y+4, 2, 2);
            ctx.fillRect(x+11, y+4, 2, 2);

            // Cheeks
            ctx.fillStyle = "#FF0000";
            ctx.fillRect(x+4, y+9, 2, 2);
            ctx.fillRect(x+10, y+9, 2, 2);
        }
    },
    grass: (ctx, x, y) => {
        ctx.fillStyle = "#609050"; // Darker green
        ctx.fillRect(x, y, 16, 16);
        ctx.fillStyle = "#306850"; // Blades
        ctx.fillRect(x+2, y+4, 2, 4);
        ctx.fillRect(x+6, y+8, 2, 4);
        ctx.fillRect(x+10, y+3, 2, 4);
        ctx.fillRect(x+12, y+10, 2, 4);
    },
    wall: (ctx, x, y) => {
        ctx.fillStyle = "#306850"; // Dark block
        ctx.fillRect(x, y, 16, 16);
        ctx.strokeStyle = "#071821";
        ctx.strokeRect(x, y, 16, 16);
        // Brick pattern
        ctx.fillStyle = "#071821";
        ctx.fillRect(x, y+7, 16, 1);
        ctx.fillRect(x+7, y, 1, 7);
        ctx.fillRect(x+3, y+8, 1, 8);
    },
    rattata: (ctx, x, y) => {
        // Purple blob
        ctx.fillStyle = "#A040A0";
        ctx.fillRect(x+20, y+20, 40, 30);
        // Ears
        ctx.fillRect(x+15, y+10, 10, 15);
        ctx.fillRect(x+55, y+10, 10, 15);
        // Eyes
        ctx.fillStyle = "#FFF";
        ctx.fillRect(x+25, y+25, 8, 8);
        ctx.fillRect(x+45, y+25, 8, 8);
        ctx.fillStyle = "#000";
        ctx.fillRect(x+27, y+27, 2, 2);
        ctx.fillRect(x+47, y+27, 2, 2);
        // Teeth
        ctx.fillStyle = "#FFF";
        ctx.fillRect(x+35, y+45, 10, 5);
    },
    pikachu_back: (ctx, x, y) => {
        // Yellow blob back
        ctx.fillStyle = "#FFCC00";
        ctx.fillRect(x+10, y+20, 40, 40);
        // Ears
        ctx.fillStyle = "#000";
        ctx.fillRect(x+5, y+5, 10, 15);
        ctx.fillRect(x+45, y+5, 10, 15);
        ctx.fillStyle = "#FFCC00";
        ctx.fillRect(x+5, y+15, 10, 10);
        ctx.fillRect(x+45, y+15, 10, 10);
        // Tail
        ctx.fillStyle = "#663300";
        ctx.fillRect(x+50, y+30, 10, 5);
        ctx.fillRect(x+55, y+20, 10, 20);
    }
};

// --- Game State Management ---
const STATES = {
    OVERWORLD: 0,
    BATTLE: 1,
    MESSAGE: 2
};

// --- Input Handling ---
const Input = {
    keys: {},
    lastKeys: {},
    init() {
        window.addEventListener('keydown', e => this.keys[e.key] = true);
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    },
    isDown(key) {
        return !!this.keys[key];
    },
    isJustPressed(key) {
        return !!this.keys[key] && !this.lastKeys[key];
    },
    update() {
        this.lastKeys = { ...this.keys };
    }
};

// --- Map Data (Simple 20x20) ---
// 1: Wall, 0: Walk, 2: Grass
const worldMap = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
    [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
    [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
    [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,2,2,2,2,0,0,0,0,0,0,2,2,2,2,0,0,0,1],
    [1,0,2,2,2,2,0,0,0,0,0,0,2,2,2,2,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

// --- Classes ---

class Entity {
    constructor(x, y, isFollower = false) {
        this.gridX = x;
        this.gridY = y;
        this.x = x * TILE_SIZE;
        this.y = y * TILE_SIZE;
        this.targetX = this.x;
        this.targetY = this.y;
        this.isMoving = false;
        this.direction = 0; // 0: Down, 1: Up, 2: Left, 3: Right
        this.isFollower = isFollower;
        this.moveQueue = []; // For the follower
    }

    update() {
        if (this.isMoving) {
            if (this.x < this.targetX) this.x += MOVE_SPEED;
            if (this.x > this.targetX) this.x -= MOVE_SPEED;
            if (this.y < this.targetY) this.y += MOVE_SPEED;
            if (this.y > this.targetY) this.y -= MOVE_SPEED;

            // Arrived
            if (Math.abs(this.x - this.targetX) < MOVE_SPEED && Math.abs(this.y - this.targetY) < MOVE_SPEED) {
                this.x = this.targetX;
                this.y = this.targetY;
                this.gridX = Math.round(this.x / TILE_SIZE);
                this.gridY = Math.round(this.y / TILE_SIZE);
                this.isMoving = false;
            }
        }
    }

    tryMove(dx, dy) {
        if (this.isMoving) return false;

        const nextGridX = this.gridX + dx;
        const nextGridY = this.gridY + dy;

        // Collision Check
        if (nextGridY < 0 || nextGridY >= worldMap.length || 
            nextGridX < 0 || nextGridX >= worldMap[0].length) {
            return false;
        }
        if (worldMap[nextGridY][nextGridX] === TILE.WALL) {
            return false;
        }

        this.targetX = nextGridX * TILE_SIZE;
        this.targetY = nextGridY * TILE_SIZE;
        this.isMoving = true;
        
        // Direction
        if (dy > 0) this.direction = 0;
        if (dy < 0) this.direction = 1;
        if (dx < 0) this.direction = 2;
        if (dx > 0) this.direction = 3;

        return true;
    }
}

class BattleSystem {
    constructor(onExit) {
        this.onExit = onExit;
        this.active = false;
        this.turn = 0; // 0: Menu, 1: Move Selection, 2: Animation, 3: Enemy Turn
        this.log = "野生的小拉达出现了!";
        
        this.playerPoke = {
            name: "皮卡丘",
            maxHp: 20,
            hp: 20,
            lvl: 5,
            moves: [
                { name: "电击", pwr: 10 },
                { name: "叫声", pwr: 0 }
            ]
        };
        
        this.enemyPoke = {
            name: "小拉达",
            maxHp: 15,
            hp: 15,
            lvl: 3
        };

        this.menuIndex = 0; // 0: Fight, 1: Run
        this.fightIndex = 0;
    }

    start() {
        this.active = true;
        this.turn = 0;
        this.log = "野生的小拉达出现了!";
        this.enemyPoke.hp = this.enemyPoke.maxHp;
        this.menuIndex = 0;
        
        // Flash effect would go here
    }

    update() {
        if (this.turn === 0) { // Main Menu
            if (Input.isJustPressed(KEYS.RIGHT)) this.menuIndex = 1;
            if (Input.isJustPressed(KEYS.LEFT)) this.menuIndex = 0;
            if (Input.isJustPressed(KEYS.A)) {
                if (this.menuIndex === 0) {
                    this.turn = 1; // Fight
                    this.fightIndex = 0;
                } else {
                    // Run
                    this.log = "安全逃离!";
                    this.turn = 4; // End
                    setTimeout(() => this.exitBattle(), 1000);
                }
            }
        } else if (this.turn === 1) { // Fight Menu
            if (Input.isJustPressed(KEYS.DOWN)) this.fightIndex = Math.min(this.fightIndex + 1, this.playerPoke.moves.length - 1);
            if (Input.isJustPressed(KEYS.UP)) this.fightIndex = Math.max(this.fightIndex - 1, 0);
            if (Input.isJustPressed(KEYS.B)) this.turn = 0; // Back
            if (Input.isJustPressed(KEYS.A)) {
                this.executePlayerMove();
            }
        }
    }

    executePlayerMove() {
        const move = this.playerPoke.moves[this.fightIndex];
        this.turn = 2;
        this.log = `皮卡丘 使用了 ${move.name}!`;
        
        // Simple damage logic
        setTimeout(() => {
            if (move.pwr > 0) {
                const dmg = Math.floor(Math.random() * 3) + 3;
                this.enemyPoke.hp = Math.max(0, this.enemyPoke.hp - dmg);
            } else {
                this.log = "小拉达 的攻击力下降了!";
            }

            if (this.enemyPoke.hp <= 0) {
                setTimeout(() => {
                    this.log = "野生的小拉达 倒下了!";
                    setTimeout(() => this.exitBattle(), 1500);
                }, 1000);
            } else {
                setTimeout(() => this.executeEnemyMove(), 1500);
            }
        }, 1000);
    }

    executeEnemyMove() {
        this.turn = 3;
        this.log = "野生的小拉达 使用了 撞击!";
        
        setTimeout(() => {
            const dmg = Math.floor(Math.random() * 2) + 1;
            this.playerPoke.hp = Math.max(0, this.playerPoke.hp - dmg);
            
            if (this.playerPoke.hp <= 0) {
                 this.log = "皮卡丘 倒下了! 你眼前一黑...";
                 setTimeout(() => {
                     // Heal and exit
                     this.playerPoke.hp = this.playerPoke.maxHp;
                     this.exitBattle();
                 }, 2000);
            } else {
                setTimeout(() => {
                    this.turn = 0;
                    this.log = "要做什么?";
                }, 1000);
            }
        }, 1000);
    }

    exitBattle() {
        this.active = false;
        this.onExit();
    }

    draw(ctx) {
        // Background
        ctx.fillStyle = PALETTE.white;
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        // Enemy Info (Top Left)
        this.drawStatus(ctx, 10, 10, this.enemyPoke);
        
        // Enemy Sprite (Top Right)
        Sprites.rattata(ctx, 100, 10);

        // Player Sprite (Bottom Left)
        Sprites.pikachu_back(ctx, 10, 60);

        // Player Info (Bottom Right)
        this.drawStatus(ctx, 80, 70, this.playerPoke, true);

        // Text Box / Menu area
        ctx.fillStyle = PALETTE.black;
        ctx.fillRect(0, 104, SCREEN_WIDTH, 40);
        ctx.fillStyle = PALETTE.white;
        ctx.fillRect(2, 106, SCREEN_WIDTH-4, 36);

        // Draw Text or Menu
        ctx.fillStyle = PALETTE.black;
        ctx.font = "10px 'Courier New'";
        
        if (this.turn === 0) {
            // Main Menu
            ctx.fillText(this.log, 10, 120);
            
            // Selection Box
            ctx.fillStyle = PALETTE.white;
            ctx.fillRect(80, 104, 80, 40);
            ctx.strokeStyle = PALETTE.black;
            ctx.strokeRect(80, 104, 79, 39);
            
            ctx.fillStyle = PALETTE.black;
            ctx.fillText("战斗", 95, 120);
            ctx.fillText("逃跑", 135, 120);
            
            // Cursor
            const cursorX = this.menuIndex === 0 ? 88 : 128;
            ctx.fillText(">", cursorX, 120);

        } else if (this.turn === 1) {
            // Fight Menu
            const m1 = this.playerPoke.moves[0];
            const m2 = this.playerPoke.moves[1];
            ctx.fillText(`${m1.name}`, 20, 120);
            if (m2) ctx.fillText(`${m2.name}`, 20, 132);
            
            ctx.fillText(">", 10, 120 + (this.fightIndex * 12));
            ctx.fillText(`PP 10/10`, 100, 120);
            ctx.fillText(`TYPE/ELEC`, 100, 130);
        } else {
            // Log messages
            ctx.fillText(this.log, 10, 125);
        }
    }

    drawStatus(ctx, x, y, poke, showNum = false) {
        ctx.fillStyle = PALETTE.black;
        ctx.fillText(poke.name, x, y);
        ctx.fillText(":L" + poke.lvl, x + 50, y);
        
        // HP Bar Border
        ctx.strokeRect(x, y + 5, 60, 4);
        
        // HP Bar Fill
        const pct = poke.hp / poke.maxHp;
        ctx.fillStyle = pct > 0.5 ? "#50C050" : pct > 0.2 ? "#F0C030" : "#F04040";
        ctx.fillRect(x + 1, y + 6, 58 * pct, 2);

        if (showNum) {
            ctx.fillStyle = PALETTE.black;
            ctx.fillText(`${poke.hp}/${poke.maxHp}`, x + 20, y + 18);
        }
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.ctx.imageSmoothingEnabled = false;
        
        Input.init();

        this.player = new Entity(4, 4);
        this.pikachu = new Entity(4, 5, true);
        
        // Pikachu initially faces player
        this.pikachu.direction = 1; 

        this.gameState = STATES.OVERWORLD;
        this.battle = new BattleSystem(() => {
            this.gameState = STATES.OVERWORLD;
        });

        this.frameCount = 0;
        this.camX = 0;
        this.camY = 0;

        // Loop
        this.lastTime = 0;
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;

        this.update();
        this.draw();
        
        Input.update();
        this.frameCount++;
        requestAnimationFrame(this.loop);
    }

    update() {
        if (this.gameState === STATES.OVERWORLD) {
            this.updateOverworld();
        } else if (this.gameState === STATES.BATTLE) {
            this.battle.update();
        }
    }

    updateOverworld() {
        // Player Movement Input
        let dx = 0;
        let dy = 0;

        if (!this.player.isMoving) {
            if (Input.isDown(KEYS.UP)) dy = -1;
            else if (Input.isDown(KEYS.DOWN)) dy = 1;
            else if (Input.isDown(KEYS.LEFT)) dx = -1;
            else if (Input.isDown(KEYS.RIGHT)) dx = 1;

            if (dx !== 0 || dy !== 0) {
                // Record previous pos for Pikachu
                const prevX = this.player.gridX;
                const prevY = this.player.gridY;
                
                if (this.player.tryMove(dx, dy)) {
                    // If player moved successfully, tell Pikachu to move to where player was
                    this.pikachu.targetX = prevX * TILE_SIZE;
                    this.pikachu.targetY = prevY * TILE_SIZE;
                    this.pikachu.gridX = prevX;
                    this.pikachu.gridY = prevY;
                    this.pikachu.isMoving = true;
                    
                    // Calc Pikachu direction
                    if (this.player.gridY < prevY) this.pikachu.direction = 1; // Up
                    if (this.player.gridY > prevY) this.pikachu.direction = 0; // Down
                    if (this.player.gridX < prevX) this.pikachu.direction = 2; // Left
                    if (this.player.gridX > prevX) this.pikachu.direction = 3; // Right

                    // Grass Encounter Check
                    if (worldMap[this.player.gridY][this.player.gridX] === TILE.GRASS) {
                        if (Math.random() < 0.15) { // 15% chance
                            // Stop movement immediately for visual effect? 
                            // Or wait until finished. Let's wait.
                            this.triggerBattleNext = true;
                        }
                    }
                } else {
                    // Turn in place
                    if (dy > 0) this.player.direction = 0;
                    if (dy < 0) this.player.direction = 1;
                    if (dx < 0) this.player.direction = 2;
                    if (dx > 0) this.player.direction = 3;
                }
            }
        }

        this.player.update();
        this.pikachu.update();

        // Check for battle trigger AFTER movement finishes
        if (this.triggerBattleNext && !this.player.isMoving) {
            this.triggerBattleNext = false;
            this.gameState = STATES.BATTLE;
            this.battle.start();
        }

        // Camera Follow
        const targetCamX = this.player.x - SCREEN_WIDTH / 2 + TILE_SIZE / 2;
        const targetCamY = this.player.y - SCREEN_HEIGHT / 2 + TILE_SIZE / 2;
        
        // Simple Lerp
        this.camX += (targetCamX - this.camX) * 0.1;
        this.camY += (targetCamY - this.camY) * 0.1;

        // Clamp Camera
        this.camX = Math.max(0, Math.min(this.camX, (worldMap[0].length * TILE_SIZE) - SCREEN_WIDTH));
        this.camY = Math.max(0, Math.min(this.camY, (worldMap.length * TILE_SIZE) - SCREEN_HEIGHT));
    }

    draw() {
        // Clear
        this.ctx.fillStyle = PALETTE.black;
        this.ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        if (this.gameState === STATES.BATTLE) {
            this.battle.draw(this.ctx);
            return;
        }

        this.ctx.save();
        this.ctx.translate(-Math.floor(this.camX), -Math.floor(this.camY));

        // Draw Map
        for (let y = 0; y < worldMap.length; y++) {
            for (let x = 0; x < worldMap[0].length; x++) {
                const t = worldMap[y][x];
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;

                // Optimization: cull off-screen
                if (px < this.camX - TILE_SIZE || px > this.camX + SCREEN_WIDTH ||
                    py < this.camY - TILE_SIZE || py > this.camY + SCREEN_HEIGHT) continue;

                if (t === TILE.WALL) Sprites.wall(this.ctx, px, py);
                else if (t === TILE.GRASS) {
                    // Draw base grass color
                    this.ctx.fillStyle = PALETTE.white; 
                    this.ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    Sprites.grass(this.ctx, px, py);
                }
                else {
                     this.ctx.fillStyle = PALETTE.white;
                     this.ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        // Draw Entities (Sort by Y for simple depth)
        const entities = [this.player, this.pikachu].sort((a,b) => a.y - b.y);
        
        entities.forEach(e => {
            if (e === this.player) Sprites.player.draw(this.ctx, e.x, e.y, this.frameCount, e.direction);
            else Sprites.pikachu.draw(this.ctx, e.x, e.y, this.frameCount, e.direction);
        });

        this.ctx.restore();
    }
}

// Start Game
window.onload = () => {
    const game = new Game();
};

</script>
</body>
</html>
