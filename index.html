<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokemon Yellow Remake (Canvas)</title>
    <!--
      CC0 Art Attribution:
      Overworld tiles are from Kenney "Tiny Town" (CC0): https://kenney.nl/assets/tiny-town
      License file included in this repo at: assets/cc0/tiny-town/License.txt
    -->
    <style>
        body {
            background-color: #202020;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 480px;
            height: 432px; /* 320x288 * 1.5 */
            background-color: #9bbc0f;
            border: 10px solid #505050;
            border-radius: 10px 10px 40px 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls-hint {
            margin-top: 20px;
            text-align: center;
            color: #aaa;
            font-size: 14px;
        }

        .key {
            background: #444;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #666;
            color: #fff;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="320" height="288"></canvas>
    </div>

    <div class="controls-hint">
        <p>控制: <span class="key">方向键</span> 移动 | <span class="key">Enter</span> 菜单</p>
        <p><span class="key">Z</span> 确定/互动 | <span class="key">X</span> 取消/加速</p>
    </div>

<script>
/**
 * POKEMON YELLOW WEB REMAKE - Phase 1 Enhanced
 */

// --- Constants & Config ---
const TILE_SIZE = 32;
const SCREEN_WIDTH = 320;
const SCREEN_HEIGHT = 288;
const FPS = 60;
const MOVE_SPEED = 3.2; // doubled for 32px tiles

const PALETTE = {
    white: "#e0f8cf",
    light: "#86c06c",
    dark: "#306850",
    black: "#071821"
};

const KEYS = {
    UP: 'ArrowUp',
    DOWN: 'ArrowDown',
    LEFT: 'ArrowLeft',
    RIGHT: 'ArrowRight',
    A: 'z',
    B: 'x',
    START: 'Enter'
};

const TILE = {
    WALK: 0,
    WALL: 1,
    GRASS: 2,
    DOOR: 3,
    FLOOR: 4,
    SIGN: 5
};

// --- Assets ---
// Tile atlas (Kenney Tiny Town, original 16x16, drawn scaled to TILE_SIZE)
const TILE_ATLAS = {
    [TILE.WALK]:  'assets/cc0/tiny-town/Tiles/tile_0000.png',
    [TILE.GRASS]: 'assets/cc0/tiny-town/Tiles/tile_0036.png',
    [TILE.WALL]:  'assets/cc0/tiny-town/Tiles/tile_0082.png',
    [TILE.FLOOR]: 'assets/cc0/tiny-town/Tiles/tile_0020.png',
    [TILE.DOOR]:  'assets/cc0/tiny-town/Tiles/tile_0108.png',
    [TILE.SIGN]:  'assets/cc0/tiny-town/Tiles/tile_0120.png'
};

const Assets = {
    tiles: new Map(),
    loaded: false,
    async preload() {
        const entries = Object.entries(TILE_ATLAS);
        const promises = entries.map(([tileId, src]) => new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve([Number(tileId), img]);
            img.onerror = () => resolve([Number(tileId), null]);
            img.src = src;
        }));
        const results = await Promise.all(promises);
        results.forEach(([tileId, img]) => { if (img) this.tiles.set(tileId, img); });
        this.loaded = true;
    },
    drawTile(ctx, tileId, x, y) {
        const img = this.tiles.get(tileId);
        if (img) {
            try {
                ctx.drawImage(img, x, y, TILE_SIZE, TILE_SIZE);
                return true;
            } catch (e) {
                // If draw fails (e.g. img not fully loaded), fallback will run
                return false;
            }
        }
        return false;
    }
};

// --- Sprite Cache: Pre-render all sprites to offscreen canvases for performance ---
const SpriteCache = {
    _cache: {},
    _make(w, h, drawFn) {
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        const cx = c.getContext('2d');
        cx.imageSmoothingEnabled = false;
        drawFn(cx);
        return c;
    },
    get(key, w, h, drawFn) {
        if (!this._cache[key]) this._cache[key] = this._make(w, h, drawFn);
        return this._cache[key];
    },
    // Helper: set pixel
    px(cx, x, y, col) { cx.fillStyle = col; cx.fillRect(x, y, 1, 1); },
    // Helper: rect
    rc(cx, x, y, w, h, col) { cx.fillStyle = col; cx.fillRect(x, y, w, h); }
};

// ========================== HIGH-DETAIL SPRITE DRAWING FUNCTIONS ==========================

function drawPlayer32(cx, frame, dir) {
    // 32x32 high-detail player (Red/Ash style) - frame 0-3 walk cycle
    const f = frame % 4;
    const p = SpriteCache.px.bind(null, cx);
    const r = SpriteCache.rc.bind(null, cx);

    // Ground shadow
    cx.fillStyle = 'rgba(0,0,0,0.25)';
    cx.beginPath();
    cx.ellipse(16, 31, 7, 2, 0, 0, Math.PI*2);
    cx.fill();

    // === SHOES ===
    const shoeOffL = [0, -1, 0, 1][f];
    const shoeOffR = [0, 1, 0, -1][f];
    r(9+shoeOffL, 28, 4, 3, '#6B3310'); r(19+shoeOffR, 28, 4, 3, '#6B3310');
    r(9+shoeOffL, 29, 4, 2, '#5a2a0e'); r(19+shoeOffR, 29, 4, 2, '#5a2a0e');
    // Shoe soles
    r(9+shoeOffL, 30, 4, 1, '#3a1a08'); r(19+shoeOffR, 30, 4, 1, '#3a1a08');

    // === LEGS / PANTS (dark blue jeans) ===
    const legOffL = [0, -1, 0, 1][f];
    const legOffR = [0, 1, 0, -1][f];
    r(10+legOffL, 23, 4, 5, '#1a1a5c'); r(18+legOffR, 23, 4, 5, '#1a1a5c');
    r(14, 23, 4, 3, '#1a1a5c');
    // Pants shadow/fold
    r(10+legOffL, 26, 4, 1, '#12124a'); r(18+legOffR, 26, 4, 1, '#12124a');
    r(12+legOffL, 24, 1, 3, '#222266'); r(20+legOffR, 24, 1, 3, '#222266');
    // Knee highlight
    r(11+legOffL, 24, 2, 1, '#2a2a6c'); r(19+legOffR, 24, 2, 1, '#2a2a6c');

    // === BELT ===
    r(9, 22, 14, 1, '#222');
    r(15, 22, 2, 1, '#FFD700'); // Belt buckle

    // === TORSO (blue jacket) ===
    r(9, 14, 14, 8, '#2266CC');
    // Jacket dark edges
    r(9, 14, 1, 8, '#1a4f99'); r(22, 14, 1, 8, '#1a4f99');
    // Jacket shadow bottom
    r(10, 20, 12, 2, '#1e5ab5');
    // Center zipper line
    r(15, 14, 2, 8, '#1a4f99');
    // Collar
    r(12, 13, 8, 1, '#FFF');
    r(11, 14, 1, 1, '#FFF'); r(20, 14, 1, 1, '#FFF');
    // Jacket highlight
    r(11, 15, 3, 1, '#3377DD'); r(19, 15, 3, 1, '#3377DD');
    // Pocket detail
    r(11, 18, 3, 2, '#1e5ab5'); r(18, 18, 3, 2, '#1e5ab5');
    r(11, 18, 3, 1, '#1a4f99'); r(18, 18, 3, 1, '#1a4f99');

    // === ARMS ===
    const armOffL = [0, 1, 0, -1][f];
    const armOffR = [0, -1, 0, 1][f];
    r(7, 15+armOffL, 2, 6, '#2266CC'); r(23, 15+armOffR, 2, 6, '#2266CC');
    r(7, 15+armOffL, 2, 1, '#1a4f99'); r(23, 15+armOffR, 2, 1, '#1a4f99');
    // Hands (skin)
    r(7, 21+armOffL, 2, 2, '#FFD8B0'); r(23, 21+armOffR, 2, 2, '#FFD8B0');
    r(7, 22+armOffL, 2, 1, '#E8C098'); r(23, 22+armOffR, 2, 1, '#E8C098');

    // === BACKPACK ===
    r(6, 16, 3, 5, '#2d8844');
    r(6, 16, 3, 1, '#3a9955'); // top highlight
    r(7, 18, 1, 2, '#1e6633'); // strap shadow
    r(6, 20, 3, 1, '#1e6633'); // bottom shadow

    // === NECK ===
    r(13, 12, 6, 1, '#FFD8B0');

    // === HEAD ===
    r(10, 5, 12, 7, '#FFD8B0');
    // Face shadow sides
    r(10, 5, 1, 7, '#E8C098'); r(21, 5, 1, 7, '#E8C098');
    // Chin shadow
    r(12, 11, 8, 1, '#E8C098');

    // === EYES ===
    // Left eye
    r(11, 7, 3, 3, '#FFF');
    r(12, 8, 2, 2, '#111');
    p(12, 8, '#333'); p(13, 8, '#222');
    p(12, 7, '#FFF'); // highlight
    // Right eye
    r(18, 7, 3, 3, '#FFF');
    r(19, 8, 2, 2, '#111');
    p(19, 8, '#333'); p(20, 8, '#222');
    p(19, 7, '#FFF'); // highlight
    // Eyebrows
    r(11, 6, 3, 1, '#1a1a2e'); r(18, 6, 3, 1, '#1a1a2e');

    // === NOSE ===
    p(15, 9, '#E8C098'); p(16, 9, '#E8C098');
    p(16, 10, '#dbb888');

    // === MOUTH ===
    r(14, 10, 4, 1, '#c97');
    p(14, 10, '#b87'); p(17, 10, '#b87');

    // === HAIR (black, spiky) ===
    r(9, 3, 14, 3, '#1a1a2e');
    r(9, 2, 14, 1, '#252540');
    r(10, 5, 1, 2, '#1a1a2e'); r(21, 5, 1, 2, '#1a1a2e');
    // Side hair
    r(9, 5, 1, 4, '#1a1a2e'); r(22, 5, 1, 4, '#1a1a2e');
    // Spiky tips
    p(10, 2, '#1a1a2e'); p(21, 2, '#1a1a2e');

    // === RED CAP ===
    r(8, 0, 16, 3, '#E03030');
    r(9, 0, 14, 1, '#F04040'); // highlight
    r(8, 2, 16, 1, '#C02020'); // brim shadow
    // Cap logo (white semi-circle)
    r(14, 0, 4, 2, '#FFF');
    p(13, 1, '#FFF'); p(18, 1, '#FFF');
    // Cap visor (extends forward)
    r(7, 3, 5, 1, '#C02020');
    r(7, 4, 4, 1, '#E03030');
    r(8, 3, 3, 1, '#FFF'); // visor shine
}

function drawPikachu32(cx, frame, dir) {
    // 32x32 high-detail Pikachu
    const f = frame % 4;
    const bounce = [0, -1, 0, -1][f];
    const p = SpriteCache.px.bind(null, cx);
    const r = SpriteCache.rc.bind(null, cx);

    // Shadow
    cx.fillStyle = 'rgba(0,0,0,0.2)';
    cx.beginPath();
    cx.ellipse(16, 30, 7, 2, 0, 0, Math.PI*2);
    cx.fill();

    // === TAIL (lightning bolt) ===
    r(24, 6+bounce, 3, 3, '#B8860B');
    r(25, 9+bounce, 3, 3, '#FFDD00');
    r(26, 12+bounce, 3, 2, '#B8860B');
    r(25, 14+bounce, 2, 2, '#FFDD00');
    r(24, 4+bounce, 4, 2, '#CC9900');
    r(27, 7+bounce, 2, 3, '#FFDD00');
    // Tail shadow
    p(24, 8+bounce, '#B88600'); p(26, 11+bounce, '#B88600');

    // === FEET ===
    r(9, 27+bounce, 5, 3, '#CC9900');
    r(18, 27+bounce, 5, 3, '#CC9900');
    r(10, 27+bounce, 3, 2, '#FFCC00');
    r(19, 27+bounce, 3, 2, '#FFCC00');
    // Toe lines
    p(10, 29+bounce, '#B88600'); p(12, 29+bounce, '#B88600');
    p(19, 29+bounce, '#B88600'); p(21, 29+bounce, '#B88600');

    // === BODY ===
    r(9, 16+bounce, 14, 11, '#FFDD00');
    // Body shading
    r(9, 16+bounce, 1, 11, '#E8C800'); r(22, 16+bounce, 1, 11, '#E8C800');
    r(9, 25+bounce, 14, 2, '#E8C800');
    // Belly
    r(11, 20+bounce, 10, 6, '#FFF5CC');
    r(12, 19+bounce, 8, 1, '#FFF5CC');
    // Belly shadow
    r(11, 25+bounce, 10, 1, '#E8DBA0');

    // === HEAD ===
    r(7, 6+bounce, 18, 11, '#FFDD00');
    // Head highlight
    r(10, 7+bounce, 12, 2, '#FFE830');
    // Head shadow sides
    r(7, 6+bounce, 1, 11, '#E8C800'); r(24, 6+bounce, 1, 11, '#E8C800');

    // === EARS ===
    // Left ear
    r(4, 0+bounce, 4, 8, '#FFDD00');
    r(5, 0+bounce, 2, 7, '#FFE830');
    // Left ear tip (black)
    r(4, 0+bounce, 4, 2, '#111');
    r(5, 0+bounce, 2, 1, '#222');
    // Right ear
    r(24, 0+bounce, 4, 8, '#FFDD00');
    r(25, 0+bounce, 2, 7, '#FFE830');
    // Right ear tip (black)
    r(24, 0+bounce, 4, 2, '#111');
    r(25, 0+bounce, 2, 1, '#222');

    // === EYES ===
    // Left eye
    r(10, 9+bounce, 3, 4, '#111');
    p(10, 9+bounce, '#FFF'); p(11, 9+bounce, '#FFF'); // highlight
    p(11, 12+bounce, '#333');
    // Right eye
    r(19, 9+bounce, 3, 4, '#111');
    p(19, 9+bounce, '#FFF'); p(20, 9+bounce, '#FFF');
    p(20, 12+bounce, '#333');

    // === NOSE ===
    r(15, 11+bounce, 2, 1, '#111');

    // === MOUTH ===
    p(14, 12+bounce, '#CC9900'); r(15, 12+bounce, 2, 1, '#111'); p(17, 12+bounce, '#CC9900');
    // Smile curve
    p(13, 13+bounce, '#CC9900'); p(18, 13+bounce, '#CC9900');

    // === RED CHEEKS ===
    r(7, 12+bounce, 3, 3, '#EE3333');
    p(8, 12+bounce, '#FF5555'); // cheek highlight
    r(22, 12+bounce, 3, 3, '#EE3333');
    p(23, 12+bounce, '#FF5555');
    // Cheek shading
    p(7, 14+bounce, '#CC2222'); p(22, 14+bounce, '#CC2222');

    // === BACK STRIPES ===
    r(12, 18+bounce, 8, 2, '#CC9900');
    r(13, 21+bounce, 6, 1, '#CC9900');
}

function drawNPCBoy32(cx, color) {
    const p = SpriteCache.px.bind(null, cx);
    const r = SpriteCache.rc.bind(null, cx);
    const mainColor = color || '#55AAEE';
    const darkColor = color ? _darkenHex(color, 0.7) : '#4488CC';

    // Shadow
    cx.fillStyle = 'rgba(0,0,0,0.25)';
    cx.beginPath(); cx.ellipse(16, 31, 7, 2, 0, 0, Math.PI*2); cx.fill();

    // Shoes (sneakers)
    r(10, 28, 4, 3, '#444'); r(18, 28, 4, 3, '#444');
    r(10, 29, 4, 2, '#333'); r(18, 29, 4, 2, '#333');
    // Shoe laces
    p(11, 28, '#FFF'); p(12, 28, '#FFF');
    p(19, 28, '#FFF'); p(20, 28, '#FFF');

    // Pants (khaki shorts)
    r(10, 23, 4, 5, '#8B7355'); r(18, 23, 4, 5, '#8B7355');
    r(14, 23, 4, 3, '#8B7355');
    // Pants shading
    r(10, 26, 4, 1, '#7a6348'); r(18, 26, 4, 1, '#7a6348');
    p(13, 24, '#9a8365'); p(19, 24, '#9a8365');

    // Belt
    r(9, 22, 14, 1, '#553322');
    r(15, 22, 2, 1, '#888');

    // Shirt
    r(9, 14, 14, 8, mainColor);
    r(9, 14, 1, 8, darkColor); r(22, 14, 1, 8, darkColor);
    // Shirt collar / V-neck
    r(14, 14, 4, 1, '#FFF');
    p(13, 15, '#FFF'); p(18, 15, '#FFF');
    // Shirt stripes
    r(10, 17, 12, 1, darkColor);
    r(10, 19, 12, 1, darkColor);
    // Shirt wrinkle highlight
    r(12, 15, 2, 1, _lightenHex(mainColor, 1.2));

    // Arms
    r(7, 15, 2, 6, mainColor); r(23, 15, 2, 6, mainColor);
    r(7, 15, 2, 1, darkColor); r(23, 15, 2, 1, darkColor);
    // Hands
    r(7, 21, 2, 2, '#FFD8B0'); r(23, 21, 2, 2, '#FFD8B0');
    p(7, 22, '#E8C098'); p(23, 22, '#E8C098');

    // Neck
    r(13, 12, 6, 2, '#FFD8B0');

    // Head
    r(10, 4, 12, 8, '#FFD8B0');
    r(10, 4, 1, 8, '#E8C098'); r(21, 4, 1, 8, '#E8C098');
    r(12, 11, 8, 1, '#E8C098');

    // Eyes
    r(11, 7, 3, 3, '#FFF'); r(18, 7, 3, 3, '#FFF');
    r(12, 8, 2, 2, '#2244AA'); r(19, 8, 2, 2, '#2244AA');
    p(13, 8, '#111'); p(20, 8, '#111');
    p(12, 7, '#FFF'); p(19, 7, '#FFF');
    // Eyebrows
    r(11, 6, 3, 1, '#6B4226'); r(18, 6, 3, 1, '#6B4226');

    // Nose
    p(15, 9, '#E8C098'); p(16, 9, '#dbb888');

    // Mouth (grin)
    r(14, 10, 4, 1, '#c97');
    p(13, 10, '#dba87'); p(18, 10, '#dba87');

    // Hair (brown, spiky)
    r(9, 2, 14, 3, '#6B4226');
    r(10, 1, 12, 1, '#7a5030');
    r(9, 4, 1, 3, '#6B4226'); r(22, 4, 1, 3, '#6B4226');
    // Spiky top
    r(11, 0, 3, 2, '#6B4226'); r(18, 0, 3, 2, '#6B4226');
    p(14, 0, '#6B4226'); p(17, 0, '#6B4226');
    // Hair highlights
    p(12, 2, '#8B6240'); p(16, 2, '#8B6240'); p(20, 2, '#8B6240');
    // Side hair
    r(9, 5, 1, 2, '#5a3618'); r(22, 5, 1, 2, '#5a3618');
}

function drawNPCGirl32(cx, color) {
    const p = SpriteCache.px.bind(null, cx);
    const r = SpriteCache.rc.bind(null, cx);
    const mainColor = color || '#FF7799';
    const darkColor = color ? _darkenHex(color, 0.7) : '#E06688';

    // Shadow
    cx.fillStyle = 'rgba(0,0,0,0.25)';
    cx.beginPath(); cx.ellipse(16, 31, 7, 2, 0, 0, Math.PI*2); cx.fill();

    // Shoes (Mary Jane style)
    r(11, 28, 3, 3, '#CC5588'); r(18, 28, 3, 3, '#CC5588');
    r(11, 30, 3, 1, '#aa4470'); r(18, 30, 3, 1, '#aa4470');
    // Shoe strap
    p(12, 28, '#aa4470'); p(19, 28, '#aa4470');

    // Dress / Skirt
    r(9, 14, 14, 14, mainColor);
    // Skirt flare bottom
    r(8, 26, 16, 2, mainColor);
    // Dress shading
    r(9, 14, 1, 14, darkColor); r(22, 14, 1, 14, darkColor);
    r(9, 26, 14, 2, darkColor);
    // Dress pattern (flower/dots)
    p(12, 18, '#FFF'); p(15, 20, '#FFE0E0'); p(19, 17, '#FFF');
    p(11, 22, '#FFE0E0'); p(17, 24, '#FFF'); p(20, 21, '#FFE0E0');
    // Waist ribbon
    r(9, 16, 14, 1, darkColor);
    r(14, 16, 4, 1, '#FFF');
    // Bow at waist
    p(13, 15, '#FFF'); p(18, 15, '#FFF');
    r(15, 15, 2, 1, '#FFE0E0');

    // Arms (skin with short sleeves)
    r(7, 14, 2, 2, mainColor); r(23, 14, 2, 2, mainColor);
    r(7, 16, 2, 5, '#FFD8B0'); r(23, 16, 2, 5, '#FFD8B0');
    r(7, 20, 2, 1, '#E8C098'); r(23, 20, 1, 1, '#E8C098');
    // Hands
    r(7, 21, 2, 1, '#FFD0A8'); r(23, 21, 2, 1, '#FFD0A8');

    // Neck
    r(13, 12, 6, 2, '#FFD8B0');

    // Head
    r(10, 4, 12, 8, '#FFD8B0');
    r(10, 4, 1, 8, '#E8C098'); r(21, 4, 1, 8, '#E8C098');
    r(12, 11, 8, 1, '#E8C098');

    // Eyes (big, anime-style, blue)
    r(11, 6, 3, 4, '#FFF'); r(18, 6, 3, 4, '#FFF');
    r(12, 7, 2, 3, '#2244AA'); r(19, 7, 2, 3, '#2244AA');
    p(12, 9, '#1133AA'); p(19, 9, '#1133AA'); // pupil bottom
    p(13, 7, '#111'); p(20, 7, '#111'); // pupil
    p(12, 6, '#FFF'); p(19, 6, '#FFF'); // highlight top
    p(12, 8, '#5577CC'); p(19, 8, '#5577CC'); // iris mid
    // Eyelashes
    p(11, 5, '#333'); p(13, 5, '#333');
    p(18, 5, '#333'); p(20, 5, '#333');

    // Blush
    r(10, 9, 2, 1, 'rgba(255,120,120,0.5)');
    r(20, 9, 2, 1, 'rgba(255,120,120,0.5)');

    // Nose
    p(15, 8, '#E8C098'); p(16, 9, '#dbb888');

    // Mouth (small smile)
    r(14, 10, 4, 1, '#e88');
    p(14, 10, '#d77'); p(17, 10, '#d77');

    // Hair (auburn, long with pigtails)
    r(9, 2, 14, 3, '#993322');
    r(10, 1, 12, 1, '#aa3828');
    // Side hair falls
    r(9, 4, 1, 6, '#993322'); r(22, 4, 1, 6, '#993322');
    r(8, 5, 1, 5, '#882218'); r(23, 5, 1, 5, '#882218');
    // Pigtails
    r(3, 3, 4, 10, '#993322'); r(25, 3, 4, 10, '#993322');
    r(4, 3, 2, 9, '#aa3828'); r(26, 3, 2, 9, '#aa3828');
    r(3, 12, 3, 2, '#882218'); r(25, 12, 3, 2, '#882218');
    // Hair ties
    r(3, 5, 4, 1, '#FF4466'); r(25, 5, 4, 1, '#FF4466');
    r(4, 4, 2, 1, '#FF6688'); r(26, 4, 2, 1, '#FF6688');
    // Hair top highlight
    p(13, 2, '#bb4432'); p(17, 2, '#bb4432');
    // Bangs
    r(11, 4, 3, 1, '#993322'); r(18, 4, 3, 1, '#993322');
}

function drawNPCGeneric32(cx, color) {
    const p = SpriteCache.px.bind(null, cx);
    const r = SpriteCache.rc.bind(null, cx);
    const mainColor = color || '#77AACC';
    const darkColor = color ? _darkenHex(color, 0.7) : '#5588AA';

    // Shadow
    cx.fillStyle = 'rgba(0,0,0,0.25)';
    cx.beginPath(); cx.ellipse(16, 31, 7, 2, 0, 0, Math.PI*2); cx.fill();

    // Shoes
    r(10, 28, 4, 3, '#444'); r(18, 28, 4, 3, '#444');
    r(10, 30, 4, 1, '#333'); r(18, 30, 4, 1, '#333');

    // Pants
    r(10, 22, 12, 6, '#556');
    r(10, 22, 1, 6, '#445'); r(21, 22, 1, 6, '#445');
    r(15, 23, 2, 5, '#445'); // center seam

    // Shirt
    r(9, 14, 14, 8, mainColor);
    r(9, 14, 1, 8, darkColor); r(22, 14, 1, 8, darkColor);
    r(10, 20, 12, 2, darkColor);
    // Collar
    r(13, 13, 6, 1, '#FFF');

    // Arms
    r(7, 15, 2, 6, mainColor); r(23, 15, 2, 6, mainColor);
    // Hands
    r(7, 21, 2, 1, '#FFD8B0'); r(23, 21, 2, 1, '#FFD8B0');

    // Neck
    r(13, 12, 6, 2, '#FFD8B0');

    // Head
    r(10, 4, 12, 8, '#FFD8B0');
    r(10, 4, 1, 8, '#E8C098'); r(21, 4, 1, 8, '#E8C098');
    r(12, 11, 8, 1, '#E8C098');

    // Eyes
    r(12, 7, 2, 2, '#000'); r(18, 7, 2, 2, '#000');
    p(12, 7, '#FFF'); p(18, 7, '#FFF');

    // Nose & mouth
    p(15, 9, '#E8C098');
    r(14, 10, 4, 1, '#c97');

    // Hair (gray/dark, neat)
    r(9, 2, 14, 3, '#555');
    r(10, 1, 12, 1, '#666');
    r(9, 4, 1, 3, '#555'); r(22, 4, 1, 3, '#555');
    // Side part
    r(10, 2, 2, 1, '#666'); p(15, 1, '#666');
}

// === BATTLE SPRITES (64x64) ===

function drawRattata64(cx) {
    const r = SpriteCache.rc.bind(null, cx);
    const p = SpriteCache.px.bind(null, cx);

    // Shadow
    cx.fillStyle = 'rgba(0,0,0,0.15)';
    cx.beginPath(); cx.ellipse(32, 60, 20, 4, 0, 0, Math.PI*2); cx.fill();

    // Tail (curly, detailed)
    r(52, 38, 4, 4, '#8E44AD'); r(54, 34, 4, 6, '#8E44AD');
    r(52, 30, 4, 5, '#8E44AD'); r(56, 36, 3, 4, '#9B59B6');
    r(54, 28, 4, 4, '#9B59B6');
    p(53, 29, '#AA6BC6'); p(55, 35, '#AA6BC6');
    r(58, 33, 2, 3, '#7D3C98');

    // Hind legs
    r(18, 50, 8, 8, '#D4A8E0'); r(38, 50, 8, 8, '#D4A8E0');
    r(18, 56, 10, 4, '#C89CD8'); r(38, 56, 10, 4, '#C89CD8');
    // Claws
    p(18, 59, '#FFF'); p(20, 59, '#FFF'); p(22, 59, '#FFF');
    p(38, 59, '#FFF'); p(40, 59, '#FFF'); p(42, 59, '#FFF');

    // Body
    r(14, 30, 40, 22, '#9B59B6');
    // Body shading
    r(14, 30, 2, 22, '#8E44AD'); r(52, 30, 2, 22, '#8E44AD');
    r(14, 48, 40, 4, '#8E44AD');
    // Body highlight
    r(20, 32, 24, 4, '#AA6BC6');
    // Belly
    r(20, 38, 24, 12, '#D4A8E0');
    r(22, 36, 20, 2, '#D4A8E0');
    // Belly shading
    r(20, 48, 24, 2, '#C89CD8');

    // Front paws
    r(16, 48, 6, 6, '#D4A8E0'); r(42, 48, 6, 6, '#D4A8E0');
    p(16, 53, '#FFF'); p(18, 53, '#FFF'); p(20, 53, '#FFF');
    p(42, 53, '#FFF'); p(44, 53, '#FFF'); p(46, 53, '#FFF');

    // Head
    r(16, 14, 32, 20, '#9B59B6');
    r(18, 12, 28, 4, '#9B59B6');
    // Head highlight
    r(22, 16, 20, 4, '#AA6BC6');
    // Head shading
    r(16, 14, 2, 20, '#8E44AD'); r(46, 14, 2, 20, '#8E44AD');

    // Ears
    r(14, 2, 10, 16, '#8E44AD');
    r(40, 2, 10, 16, '#8E44AD');
    // Inner ears
    r(16, 6, 6, 10, '#D4A8E0');
    r(42, 6, 6, 10, '#D4A8E0');
    // Ear highlights
    r(17, 7, 4, 4, '#E0B8EA');
    r(43, 7, 4, 4, '#E0B8EA');

    // Eyes
    r(20, 18, 8, 8, '#FFF'); r(36, 18, 8, 8, '#FFF');
    // Iris (red)
    r(24, 20, 4, 5, '#E33');  r(40, 20, 4, 5, '#E33');
    r(23, 21, 1, 3, '#E33');  r(39, 21, 1, 3, '#E33');
    // Pupils
    r(25, 21, 2, 3, '#111'); r(41, 21, 2, 3, '#111');
    // Eye highlights
    p(23, 19, '#FFF'); p(24, 19, '#FFF');
    p(39, 19, '#FFF'); p(40, 19, '#FFF');
    // Eye shadow
    r(20, 18, 8, 1, '#DDD'); r(36, 18, 8, 1, '#DDD');

    // Nose
    r(30, 27, 4, 3, '#FF69B4');
    p(31, 27, '#FF88CC'); // nose highlight

    // Teeth (prominent)
    r(26, 30, 4, 5, '#FFF'); r(34, 30, 4, 5, '#FFF');
    r(27, 30, 2, 4, '#F8F8F8'); r(35, 30, 2, 4, '#F8F8F8');
    // Tooth shadow
    r(26, 34, 4, 1, '#DDD'); r(34, 34, 4, 1, '#DDD');

    // Whiskers
    r(6, 24, 12, 1, '#888'); r(6, 28, 14, 1, '#888');
    r(46, 24, 12, 1, '#888'); r(46, 28, 14, 1, '#888');
    r(4, 26, 10, 1, '#777'); r(50, 26, 10, 1, '#777');

    // Fur detail on cheeks
    p(18, 28, '#AA6BC6'); p(46, 28, '#AA6BC6');
    p(17, 26, '#AA6BC6'); p(47, 26, '#AA6BC6');
}

function drawPidgey64(cx) {
    const r = SpriteCache.rc.bind(null, cx);
    const p = SpriteCache.px.bind(null, cx);

    // Shadow
    cx.fillStyle = 'rgba(0,0,0,0.15)';
    cx.beginPath(); cx.ellipse(32, 60, 18, 3, 0, 0, Math.PI*2); cx.fill();

    // Tail feathers
    r(8, 44, 12, 8, '#8B6240');
    r(6, 48, 8, 4, '#8B6240');
    // Dark tail tips
    r(6, 50, 8, 2, '#111');
    r(8, 48, 4, 2, '#5a4020');
    // Tail feather lines
    p(10, 45, '#7a5535'); p(12, 46, '#7a5535'); p(14, 47, '#7a5535');

    // Feet
    r(24, 52, 4, 8, '#FF9966'); r(36, 52, 4, 8, '#FF9966');
    r(20, 58, 10, 2, '#FF9966'); r(34, 58, 10, 2, '#FF9966');
    // Talons
    p(20, 59, '#CC7744'); p(24, 59, '#CC7744'); p(28, 59, '#CC7744');
    p(34, 59, '#CC7744'); p(38, 59, '#CC7744'); p(42, 59, '#CC7744');

    // Body
    r(16, 26, 32, 24, '#A0724A');
    // Body highlight
    r(22, 28, 20, 6, '#B08050');
    // Body shading
    r(16, 26, 2, 24, '#8B6240'); r(46, 26, 2, 24, '#8B6240');
    r(16, 46, 32, 4, '#8B6240');
    // Belly
    r(20, 36, 24, 12, '#F5DEB3');
    r(22, 34, 20, 2, '#F5DEB3');
    // Belly feather texture
    p(24, 38, '#EED8A8'); p(28, 40, '#EED8A8'); p(32, 38, '#EED8A8');
    p(36, 42, '#EED8A8'); p(26, 44, '#EED8A8');
    // Belly shading
    r(20, 46, 24, 2, '#E8D0A0');

    // Wing (left, extended)
    r(10, 28, 10, 18, '#8B6240');
    r(6, 32, 6, 12, '#8B6240');
    // Wing feather detail
    r(10, 40, 8, 3, '#F5DEB3');
    r(6, 38, 6, 2, '#A0724A');
    // Wing highlight
    r(12, 30, 6, 4, '#A07848');
    // Wing feather lines
    p(8, 34, '#7a5535'); p(10, 36, '#7a5535'); p(12, 38, '#7a5535');

    // Head
    r(20, 10, 24, 18, '#A0724A');
    r(22, 8, 20, 4, '#A0724A');
    // Head highlight
    r(26, 12, 12, 6, '#B08050');
    // Head shading
    r(20, 10, 2, 18, '#8B6240'); r(42, 10, 2, 18, '#8B6240');

    // Crest feathers (golden/cream)
    r(26, 4, 8, 8, '#E8C070');
    r(28, 2, 6, 4, '#E8C070');
    r(30, 0, 4, 4, '#F0D080');
    // Crest highlight
    p(30, 2, '#F8E090'); p(32, 3, '#F8E090');
    // Crest shading
    r(26, 10, 8, 2, '#D0A858');

    // Eye
    r(34, 14, 8, 8, '#FFF');
    r(36, 16, 4, 4, '#111');
    r(37, 17, 2, 2, '#000');
    p(35, 15, '#FFF'); p(36, 15, '#FFF'); // highlight
    // Eye ring
    r(34, 14, 8, 1, '#8B6240'); r(34, 21, 8, 1, '#8B6240');

    // Beak
    r(44, 18, 10, 4, '#FF9966');
    r(44, 22, 8, 3, '#FF8855');
    r(44, 18, 10, 1, '#FFB088'); // beak highlight
    r(44, 24, 6, 1, '#DD7744'); // beak shadow
    // Beak tip
    r(52, 19, 2, 2, '#E87744');
    // Nostril
    p(46, 19, '#DD7744');
}

function drawCaterpie64(cx) {
    const r = SpriteCache.rc.bind(null, cx);
    const p = SpriteCache.px.bind(null, cx);

    // Shadow
    cx.fillStyle = 'rgba(0,0,0,0.15)';
    cx.beginPath(); cx.ellipse(34, 58, 22, 4, 0, 0, Math.PI*2); cx.fill();

    // Tail spike
    r(4, 42, 6, 6, '#FFEE55');
    r(6, 40, 4, 4, '#FFE830');
    p(5, 41, '#FFF8AA');

    // Body segments (5 segments, undulating)
    const segs = [[8,40],[16,42],[24,40],[32,42],[40,40]];
    segs.forEach(([sx,sy], i) => {
        // Main segment
        r(sx, sy, 10, 12, '#55CC55');
        // Segment shading (top lighter, bottom darker)
        r(sx, sy, 10, 3, '#66DD66');
        r(sx, sy+10, 10, 2, '#44AA44');
        // Side shading
        r(sx, sy, 1, 12, '#44AA44');
        r(sx+9, sy, 1, 12, '#44AA44');
        // Yellow belly ring
        r(sx+3, sy+7, 5, 3, '#FFEE55');
        r(sx+4, sy+8, 3, 1, '#FFF888');
        // Circle pattern on sides
        p(sx+2, sy+4, '#44AA44'); p(sx+7, sy+4, '#44AA44');
        // Feet (tiny)
        r(sx+2, sy+12, 3, 2, '#44AA44');
        r(sx+6, sy+12, 3, 2, '#44AA44');
    });

    // Head (bigger, rounder)
    r(48, 30, 14, 18, '#55CC55');
    r(50, 28, 10, 4, '#55CC55');
    // Head shading
    r(48, 30, 1, 18, '#44AA44'); r(61, 30, 1, 18, '#44AA44');
    r(48, 46, 14, 2, '#44AA44');
    // Head highlight
    r(52, 32, 6, 4, '#66DD66');

    // Eyes (big, cute, yellow)
    r(49, 34, 6, 6, '#FFF');
    r(57, 34, 6, 6, '#FFF');
    // Iris
    r(51, 36, 3, 3, '#FFEE55');
    r(59, 36, 3, 3, '#FFEE55');
    // Pupil
    r(52, 37, 2, 2, '#111');
    r(60, 37, 2, 2, '#111');
    // Eye highlight
    p(51, 35, '#FFF'); p(52, 35, '#FFF');
    p(59, 35, '#FFF'); p(60, 35, '#FFF');
    // Eye outline
    r(49, 34, 6, 1, '#44AA44'); r(57, 34, 6, 1, '#44AA44');

    // Antenna (red Y-shape)
    r(53, 20, 2, 10, '#EE3333');
    r(57, 20, 2, 10, '#EE3333');
    r(51, 16, 2, 6, '#EE3333');
    r(59, 16, 2, 6, '#EE3333');
    // Antenna tips (round)
    r(50, 14, 4, 4, '#FF4444');
    r(58, 14, 4, 4, '#FF4444');
    p(51, 15, '#FF6666'); p(59, 15, '#FF6666');

    // Mouth (small, happy)
    r(54, 44, 4, 1, '#44AA44');
    p(53, 43, '#44AA44'); p(58, 43, '#44AA44');
}

function drawOnix64(cx) {
    const r = SpriteCache.rc.bind(null, cx);
    const p = SpriteCache.px.bind(null, cx);

    // Shadow
    cx.fillStyle = 'rgba(0,0,0,0.15)';
    cx.beginPath(); cx.ellipse(32, 62, 24, 3, 0, 0, Math.PI*2); cx.fill();

    // Tail segment (smallest)
    r(2, 50, 10, 10, '#888');
    r(3, 51, 8, 8, '#777');
    r(4, 52, 4, 4, '#999');
    p(3, 51, '#AAA'); // highlight

    // Body segment 2
    r(10, 44, 12, 12, '#888');
    r(11, 45, 10, 10, '#777');
    r(12, 46, 5, 5, '#999');
    p(11, 45, '#AAA');
    // Crack detail
    p(14, 48, '#666'); p(16, 50, '#666'); p(18, 47, '#666');

    // Body segment 3
    r(20, 36, 14, 14, '#8a8a8a');
    r(21, 37, 12, 12, '#777');
    r(22, 38, 6, 6, '#999');
    p(21, 37, '#AAA');
    // Rock texture
    p(24, 42, '#666'); p(28, 40, '#666'); p(26, 46, '#666');
    r(30, 44, 3, 2, '#666');

    // Body segment 4
    r(30, 28, 14, 14, '#8a8a8a');
    r(31, 29, 12, 12, '#777');
    r(32, 30, 6, 6, '#999');
    p(31, 29, '#AAA');
    // Rock texture
    p(34, 34, '#666'); p(38, 32, '#666'); p(36, 38, '#666');

    // === HEAD (large boulder, detailed) ===
    r(36, 6, 24, 24, '#8a8a8a');
    r(38, 8, 20, 20, '#777');
    // Head highlight (top)
    r(40, 8, 16, 4, '#999');
    r(42, 6, 12, 2, '#AAA');
    // Head shadow (bottom)
    r(38, 24, 20, 4, '#666');

    // Horn (rocky spike)
    r(46, 0, 6, 8, '#AAA');
    r(47, 0, 4, 6, '#BBB');
    r(48, 0, 2, 4, '#CCC');
    // Horn highlight
    p(48, 1, '#DDD');

    // Eyes (angry, white with black pupils)
    r(40, 14, 8, 6, '#FFF');
    r(52, 14, 8, 6, '#FFF');
    // Pupils
    r(44, 15, 3, 4, '#111');
    r(56, 15, 3, 4, '#111');
    // Eye glint
    p(43, 15, '#FFF'); p(55, 15, '#FFF');
    // Angry brows (angled down towards center)
    r(40, 12, 3, 2, '#555'); r(43, 13, 3, 1, '#555'); r(46, 14, 2, 1, '#555');
    r(52, 14, 2, 1, '#555'); r(54, 13, 3, 1, '#555'); r(57, 12, 3, 2, '#555');

    // Jaw
    r(40, 24, 18, 6, '#777');
    r(41, 25, 16, 4, '#666');
    // Teeth (jagged)
    r(42, 24, 3, 3, '#FFF'); r(47, 24, 3, 3, '#FFF'); r(52, 24, 3, 3, '#FFF');
    r(43, 24, 1, 2, '#EEE'); r(48, 24, 1, 2, '#EEE'); r(53, 24, 1, 2, '#EEE');
    // Lower jaw teeth
    r(44, 28, 3, 2, '#FFF'); r(50, 28, 3, 2, '#FFF');

    // Rock texture spots
    p(42, 10, '#666'); p(50, 12, '#666'); p(56, 10, '#666');
    p(38, 18, '#888'); p(44, 20, '#888');
    // Cracks
    r(48, 18, 1, 4, '#555'); r(54, 16, 1, 3, '#555');
}

function drawPikachuBack64(cx) {
    const r = SpriteCache.rc.bind(null, cx);
    const p = SpriteCache.px.bind(null, cx);

    // === TAIL (lightning bolt, detailed) ===
    r(48, 18, 6, 4, '#CC9900');
    r(50, 14, 6, 6, '#CC9900');
    r(52, 8, 6, 8, '#FFDD00');
    r(54, 4, 6, 6, '#CC9900');
    r(56, 2, 4, 4, '#FFDD00');
    // Tail highlight
    r(53, 10, 3, 4, '#FFE830');
    r(55, 4, 3, 3, '#FFE830');
    // Tail shadow
    p(48, 21, '#B88600'); p(50, 18, '#B88600');
    // Tail base brown
    r(46, 20, 4, 4, '#B88600');

    // === FEET ===
    r(16, 54, 10, 6, '#CC9900');
    r(38, 54, 10, 6, '#CC9900');
    r(17, 54, 8, 5, '#FFDD00');
    r(39, 54, 8, 5, '#FFDD00');
    // Toe pads
    r(18, 58, 3, 2, '#E8C800'); r(22, 58, 3, 2, '#E8C800');
    r(40, 58, 3, 2, '#E8C800'); r(44, 58, 3, 2, '#E8C800');

    // === BODY ===
    r(14, 28, 36, 28, '#FFDD00');
    // Body shading
    r(14, 28, 2, 28, '#E8C800'); r(48, 28, 2, 28, '#E8C800');
    r(14, 52, 36, 4, '#E8C800');
    // Body highlight
    r(20, 30, 24, 6, '#FFE830');

    // Back stripes (two brown stripes)
    r(18, 32, 28, 4, '#CC9900');
    r(20, 38, 24, 3, '#CC9900');
    // Stripe detail
    r(20, 33, 24, 1, '#B88600');
    r(22, 39, 20, 1, '#B88600');

    // Belly hint at sides
    r(14, 48, 6, 6, '#FFF5CC');
    r(44, 48, 6, 6, '#FFF5CC');

    // === HEAD ===
    r(16, 14, 32, 18, '#FFDD00');
    r(18, 12, 28, 4, '#FFDD00');
    // Head highlight
    r(22, 14, 20, 4, '#FFE830');
    // Head shading
    r(16, 14, 2, 18, '#E8C800'); r(46, 14, 2, 18, '#E8C800');

    // === EARS ===
    // Left ear
    r(10, 2, 10, 14, '#FFDD00');
    r(12, 2, 6, 12, '#FFE830');
    // Left ear tip (black)
    r(10, 2, 10, 4, '#111');
    r(12, 2, 6, 2, '#222');
    // Right ear
    r(44, 2, 10, 14, '#FFDD00');
    r(46, 2, 6, 12, '#FFE830');
    // Right ear tip (black)
    r(44, 2, 10, 4, '#111');
    r(46, 2, 6, 2, '#222');
    // Ear inner
    r(13, 8, 4, 6, '#E8C800');
    r(47, 8, 4, 6, '#E8C800');

    // === RED CHEEKS (visible from behind) ===
    r(14, 24, 6, 4, '#EE3333');
    r(44, 24, 6, 4, '#EE3333');
    // Cheek highlight
    p(15, 25, '#FF5555'); p(45, 25, '#FF5555');
    // Cheek shadow
    r(14, 27, 6, 1, '#CC2222'); r(44, 27, 6, 1, '#CC2222');

    // === BACK OF HEAD detail ===
    // Back head crown
    r(24, 12, 16, 2, '#E8C800');
    // Ear base
    r(18, 14, 4, 2, '#E8C800');
    r(42, 14, 4, 2, '#E8C800');
}

// === TILE SPRITES (32x32 with texture) ===

function drawGrassTile(cx) {
    const r = SpriteCache.rc.bind(null, cx);
    const p = SpriteCache.px.bind(null, cx);

    // Base
    r(0, 0, 32, 32, '#5a9a48');
    // Variation bands
    r(0, 16, 32, 16, '#4e8e3c');
    r(0, 24, 32, 8, '#4a8638');

    // Light patches
    r(4, 4, 6, 6, '#68a856'); r(20, 12, 6, 4, '#68a856');
    r(12, 20, 8, 6, '#5ea04e'); r(2, 14, 5, 4, '#60a44e');
    // Dark patches
    r(16, 2, 4, 6, '#3e7a2e'); r(26, 16, 4, 6, '#3e7a2e');
    r(6, 24, 5, 4, '#3e7a2e');

    // Grass blade V shapes (dark green)
    // Blade 1
    p(4, 4, '#3a7a30'); p(5, 3, '#3a7a30'); p(6, 2, '#3a7a30'); p(7, 3, '#3a7a30'); p(8, 4, '#3a7a30');
    p(6, 5, '#448834'); p(6, 6, '#448834'); p(6, 7, '#448834');
    // Blade 2
    p(14, 12, '#3a7a30'); p(15, 11, '#3a7a30'); p(16, 10, '#3a7a30'); p(17, 11, '#3a7a30'); p(18, 12, '#3a7a30');
    p(16, 13, '#448834'); p(16, 14, '#448834'); p(16, 15, '#448834');
    // Blade 3
    p(24, 2, '#3a7a30'); p(25, 1, '#3a7a30'); p(26, 0, '#3a7a30'); p(27, 1, '#3a7a30'); p(28, 2, '#3a7a30');
    p(26, 3, '#448834'); p(26, 4, '#448834'); p(26, 5, '#448834');
    // Blade 4
    p(2, 18, '#3a7a30'); p(3, 17, '#3a7a30'); p(4, 16, '#3a7a30'); p(5, 17, '#3a7a30'); p(6, 18, '#3a7a30');
    p(4, 19, '#448834'); p(4, 20, '#448834');
    // Blade 5
    p(20, 22, '#3a7a30'); p(21, 21, '#3a7a30'); p(22, 20, '#3a7a30'); p(23, 21, '#3a7a30'); p(24, 22, '#3a7a30');
    p(22, 23, '#448834'); p(22, 24, '#448834');
    // Blade 6
    p(28, 16, '#3a7a30'); p(29, 15, '#3a7a30'); p(30, 14, '#3a7a30');
    p(29, 17, '#448834'); p(29, 18, '#448834');
    // Blade 7
    p(10, 26, '#3a7a30'); p(11, 25, '#3a7a30'); p(12, 26, '#3a7a30');
    p(11, 27, '#448834'); p(11, 28, '#448834');
    // Blade 8
    p(27, 26, '#3a7a30'); p(28, 25, '#3a7a30'); p(29, 26, '#3a7a30');
    p(28, 27, '#448834');

    // Yellow-green highlights
    p(2, 8, '#7ab858'); p(12, 16, '#7ab858'); p(20, 6, '#7ab858');
    p(28, 20, '#7ab858'); p(8, 26, '#7ab858'); p(18, 28, '#7ab858');
    p(24, 10, '#7ab858'); p(6, 14, '#7ab858');

    // Small flowers
    p(10, 10, '#FFE855'); p(11, 10, '#FFE855'); p(10, 11, '#FFD835');
    p(26, 24, '#FF9999'); p(27, 24, '#FF9999'); p(26, 25, '#FF7777');
    // Extra flower
    p(3, 28, '#FFE855'); p(4, 28, '#FFD835');
}

function drawWallTile(cx) {
    const r = SpriteCache.rc.bind(null, cx);
    const p = SpriteCache.px.bind(null, cx);

    // Mortar base
    r(0, 0, 32, 32, '#3a4848');

    // Brick row 1 (top, 2 bricks)
    r(1, 1, 14, 6, '#506868');
    r(17, 1, 14, 6, '#506868');
    // Brick row 2 (offset)
    r(1, 9, 7, 6, '#4c6464');
    r(10, 9, 14, 6, '#4c6464');
    r(26, 9, 5, 6, '#4c6464');
    // Brick row 3
    r(1, 17, 14, 6, '#506868');
    r(17, 17, 14, 6, '#506868');
    // Brick row 4 (offset)
    r(1, 25, 7, 6, '#4c6464');
    r(10, 25, 14, 6, '#4c6464');
    r(26, 25, 5, 6, '#4c6464');

    // Mortar lines (horizontal)
    r(0, 7, 32, 2, '#2a3838');
    r(0, 15, 32, 2, '#2a3838');
    r(0, 23, 32, 2, '#2a3838');
    r(0, 31, 32, 1, '#2a3838');
    // Mortar lines (vertical, row 1 & 3)
    r(15, 0, 2, 7, '#2a3838');
    r(15, 17, 2, 6, '#2a3838');
    // Mortar lines (vertical, row 2 & 4 offset)
    r(8, 9, 2, 6, '#2a3838');
    r(24, 9, 2, 6, '#2a3838');
    r(8, 25, 2, 6, '#2a3838');
    r(24, 25, 2, 6, '#2a3838');

    // Brick highlights (top edge)
    r(1, 1, 14, 1, '#607878'); r(17, 1, 14, 1, '#607878');
    r(1, 9, 7, 1, '#5c7474'); r(10, 9, 14, 1, '#5c7474'); r(26, 9, 5, 1, '#5c7474');
    r(1, 17, 14, 1, '#607878'); r(17, 17, 14, 1, '#607878');
    r(1, 25, 7, 1, '#5c7474'); r(10, 25, 14, 1, '#5c7474'); r(26, 25, 5, 1, '#5c7474');

    // Brick shadows (bottom edge)
    r(1, 6, 14, 1, '#445858'); r(17, 6, 14, 1, '#445858');
    r(1, 14, 7, 1, '#445858'); r(10, 14, 14, 1, '#445858'); r(26, 14, 5, 1, '#445858');
    r(1, 22, 14, 1, '#445858'); r(17, 22, 14, 1, '#445858');
    r(1, 30, 7, 1, '#445858'); r(10, 30, 14, 1, '#445858'); r(26, 30, 5, 1, '#445858');

    // Texture spots
    p(5, 3, '#587070'); p(22, 4, '#587070'); p(6, 11, '#587070');
    p(14, 12, '#445858'); p(28, 11, '#445070');
    p(4, 19, '#4a6060'); p(20, 20, '#4a6060'); p(8, 27, '#587070');
    p(18, 28, '#445858'); p(29, 27, '#4a6060');
}

function drawFloorTile(cx) {
    const r = SpriteCache.rc.bind(null, cx);
    const p = SpriteCache.px.bind(null, cx);

    // Base wood color
    r(0, 0, 32, 32, '#D8C8A8');

    // Wood planks (horizontal bands)
    r(0, 0, 32, 8, '#D4C4A4');
    r(0, 8, 32, 8, '#CFC0A0');
    r(0, 16, 32, 8, '#D0C0A0');
    r(0, 24, 32, 8, '#CCBC9C');

    // Plank gaps
    r(0, 7, 32, 1, '#B8B098'); r(0, 15, 32, 1, '#B8B098');
    r(0, 23, 32, 1, '#B8B098'); r(0, 31, 32, 1, '#B8B098');

    // Wood grain (long subtle lines)
    r(4, 2, 2, 1, '#C8B898'); r(10, 2, 3, 1, '#C8B898'); r(20, 3, 2, 1, '#C8B898'); r(28, 4, 2, 1, '#C8B898');
    r(6, 10, 3, 1, '#C4B494'); r(16, 10, 2, 1, '#C4B494'); r(24, 12, 3, 1, '#C4B494');
    r(2, 18, 2, 1, '#C4B494'); r(12, 18, 3, 1, '#C4B494'); r(22, 20, 2, 1, '#C4B494');
    r(8, 26, 3, 1, '#C0B090'); r(18, 26, 2, 1, '#C0B090'); r(26, 28, 3, 1, '#C0B090');
    r(3, 5, 2, 1, '#C8B898'); r(14, 4, 2, 1, '#C8B898');
    r(9, 13, 2, 1, '#C4B494'); r(27, 11, 2, 1, '#C4B494');

    // Knots
    r(14, 10, 2, 2, '#B0A888'); r(15, 11, 2, 2, '#A8A080');
    r(6, 26, 2, 2, '#B0A888');

    // Edge highlights
    r(0, 0, 32, 1, '#E0D8C0');
    r(0, 8, 2, 1, '#D8D0B8'); r(0, 16, 2, 1, '#D8D0B8'); r(0, 24, 2, 1, '#D8D0B8');

    // Nail heads
    p(2, 3, '#A0A0A0'); p(29, 3, '#A0A0A0');
    p(2, 19, '#A0A0A0'); p(29, 19, '#A0A0A0');
}

function drawDoorTile(cx) {
    const r = SpriteCache.rc.bind(null, cx);
    const p = SpriteCache.px.bind(null, cx);

    // Dark frame
    r(0, 0, 32, 32, '#1a1a2e');

    // Door panels
    r(4, 2, 24, 30, '#5a3a1a');
    // Inner panels (4 panels)
    r(6, 4, 8, 10, '#6B4426');
    r(18, 4, 8, 10, '#6B4426');
    r(6, 18, 8, 10, '#6B4426');
    r(18, 18, 8, 10, '#6B4426');
    // Panel bevels (highlight top-left)
    r(6, 4, 8, 1, '#7a5533'); r(18, 4, 8, 1, '#7a5533');
    r(6, 18, 8, 1, '#7a5533'); r(18, 18, 8, 1, '#7a5533');
    r(6, 4, 1, 10, '#7a5533'); r(18, 4, 1, 10, '#7a5533');
    r(6, 18, 1, 10, '#7a5533'); r(18, 18, 1, 10, '#7a5533');
    // Panel shadow (bottom-right)
    r(6, 13, 8, 1, '#4a2a10'); r(18, 13, 8, 1, '#4a2a10');
    r(6, 27, 8, 1, '#4a2a10'); r(18, 27, 8, 1, '#4a2a10');
    r(13, 4, 1, 10, '#4a2a10'); r(25, 4, 1, 10, '#4a2a10');
    r(13, 18, 1, 10, '#4a2a10'); r(25, 18, 1, 10, '#4a2a10');

    // Center divider
    r(14, 2, 4, 30, '#4a2a10');
    r(15, 2, 2, 30, '#3a1a08');

    // Door handle (gold)
    r(20, 16, 3, 3, '#FFD700');
    r(20, 16, 2, 2, '#FFE840'); // highlight
    r(22, 18, 1, 1, '#CC9900'); // shadow

    // Wood grain texture
    p(8, 8, '#5a3418'); p(20, 8, '#5a3418'); p(11, 6, '#5a3418');
    p(10, 22, '#5a3418'); p(22, 22, '#5a3418'); p(8, 24, '#5a3418');
    p(23, 10, '#5a3418'); p(9, 20, '#5a3418');

    // Threshold
    r(4, 30, 24, 2, '#3a2a18');
    r(4, 31, 24, 1, '#2a1a0a');
}

function drawSignTile(cx) {
    const r = SpriteCache.rc.bind(null, cx);
    const p = SpriteCache.px.bind(null, cx);

    // Ground behind sign
    r(0, 0, 32, 32, '#5a9a48');
    r(0, 24, 32, 8, '#4e8e3c');
    // Grass detail
    p(4, 28, '#3a7a30'); p(5, 27, '#3a7a30'); p(6, 28, '#3a7a30');
    p(24, 29, '#3a7a30'); p(25, 28, '#3a7a30'); p(26, 29, '#3a7a30');

    // Post
    r(14, 20, 4, 12, '#6B3410');
    r(14, 20, 2, 12, '#7a4018'); // post highlight
    r(16, 22, 2, 10, '#5a2a0a'); // post shadow

    // Board
    r(4, 4, 24, 18, '#A0622E');
    // Board frame
    r(4, 4, 24, 2, '#8B4513'); r(4, 20, 24, 2, '#8B4513');
    r(4, 4, 2, 18, '#8B4513'); r(26, 4, 2, 18, '#8B4513');
    // Board highlight
    r(6, 6, 20, 2, '#B8783E');
    r(6, 8, 2, 2, '#B07030');
    // Board shadow
    r(6, 18, 20, 2, '#7a3a10');

    // Paper/notice
    r(8, 8, 16, 10, '#F0E8D0');
    r(8, 8, 16, 2, '#F8F0E0'); // paper highlight

    // Text lines
    r(10, 10, 12, 1, '#333');
    r(10, 13, 8, 1, '#555');
    r(10, 15, 10, 1, '#555');

    // Nails
    r(8, 8, 2, 2, '#888'); r(22, 8, 2, 2, '#888');
    p(8, 8, '#AAA'); p(22, 8, '#AAA'); // nail highlight
}

// === COLOR HELPERS ===
function _darkenHex(hex, factor) {
    try {
        const r = parseInt(hex.slice(1,3),16);
        const g = parseInt(hex.slice(3,5),16);
        const b = parseInt(hex.slice(5,7),16);
        return '#' + [r,g,b].map(v => Math.max(0, Math.floor(v*factor)).toString(16).padStart(2,'0')).join('');
    } catch(e) { return hex; }
}
function _lightenHex(hex, factor) {
    try {
        const r = parseInt(hex.slice(1,3),16);
        const g = parseInt(hex.slice(3,5),16);
        const b = parseInt(hex.slice(5,7),16);
        return '#' + [r,g,b].map(v => Math.min(255, Math.floor(v*factor)).toString(16).padStart(2,'0')).join('');
    } catch(e) { return hex; }
}

// ========================== SPRITES OBJECT (API-compatible) ==========================

const Sprites = {
    player: {
        draw: (ctx, x, y, frame, dir) => {
            const f = frame ? Math.floor(frame / 8) % 4 : 0;
            const key = `player_${f}_${dir}`;
            const cached = SpriteCache.get(key, 32, 32, cx => drawPlayer32(cx, f, dir));
            ctx.drawImage(cached, x, y);
        }
    },
    pikachu: {
        draw: (ctx, x, y, frame, dir) => {
            const f = frame ? Math.floor(frame / 10) % 4 : 0;
            const key = `pikachu_${f}_${dir}`;
            const cached = SpriteCache.get(key, 32, 32, cx => drawPikachu32(cx, f, dir));
            ctx.drawImage(cached, x, y);
        }
    },
    npc_boy: {
        draw: (ctx, x, y, color) => {
            const key = `npc_boy_${color||'def'}`;
            const cached = SpriteCache.get(key, 32, 32, cx => drawNPCBoy32(cx, color));
            ctx.drawImage(cached, x, y);
        }
    },
    npc_girl: {
        draw: (ctx, x, y, color) => {
            const key = `npc_girl_${color||'def'}`;
            const cached = SpriteCache.get(key, 32, 32, cx => drawNPCGirl32(cx, color));
            ctx.drawImage(cached, x, y);
        }
    },
    npc: {
        draw: (ctx, x, y, color) => {
            const key = `npc_gen_${color||'def'}`;
            const cached = SpriteCache.get(key, 32, 32, cx => drawNPCGeneric32(cx, color));
            ctx.drawImage(cached, x, y);
        }
    },
    grass: (ctx, x, y) => {
        const cached = SpriteCache.get('tile_grass', 32, 32, drawGrassTile);
        ctx.drawImage(cached, x, y);
    },
    wall: (ctx, x, y) => {
        const cached = SpriteCache.get('tile_wall', 32, 32, drawWallTile);
        ctx.drawImage(cached, x, y);
    },
    floor: (ctx, x, y) => {
        const cached = SpriteCache.get('tile_floor', 32, 32, drawFloorTile);
        ctx.drawImage(cached, x, y);
    },
    door: (ctx, x, y) => {
        const cached = SpriteCache.get('tile_door', 32, 32, drawDoorTile);
        ctx.drawImage(cached, x, y);
    },
    sign: (ctx, x, y) => {
        const cached = SpriteCache.get('tile_sign', 32, 32, drawSignTile);
        ctx.drawImage(cached, x, y);
    },
    // Battle sprites (64x64)
    rattata: (ctx, x, y) => {
        const cached = SpriteCache.get('battle_rattata', 64, 64, drawRattata64);
        ctx.drawImage(cached, x, y);
    },
    pidgey: (ctx, x, y) => {
        const cached = SpriteCache.get('battle_pidgey', 64, 64, drawPidgey64);
        ctx.drawImage(cached, x, y);
    },
    caterpie: (ctx, x, y) => {
        const cached = SpriteCache.get('battle_caterpie', 64, 64, drawCaterpie64);
        ctx.drawImage(cached, x, y);
    },
    onix: (ctx, x, y) => {
        const cached = SpriteCache.get('battle_onix', 64, 64, drawOnix64);
        ctx.drawImage(cached, x, y);
    },
    pikachu_back: (ctx, x, y) => {
        const cached = SpriteCache.get('battle_pikachu_back', 64, 64, drawPikachuBack64);
        ctx.drawImage(cached, x, y);
    }
};

// --- Map Data ---
const MAPS = {
    town: {
        id: 'town',
        width: 20, height: 20,
        data: [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,4,4,4,1,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,4,4,4,1,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,4,4,4,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,1,3,1,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 19,9 Exit East
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 19,10 Exit East
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 5, y: 7, target: 'house', targetX: 5, targetY: 8 },
            { x: 19, y: 9, target: 'route', targetX: 1, targetY: 9 },
            { x: 19, y: 10, target: 'route', targetX: 1, targetY: 10 }
        ],
        npcs: [
            { x: 8, y: 12, text: ["你好！", "这里是真新镇。"], color: "#88ccff", sprite: "npc_girl" },
            { x: 14, y: 6, text: ["小心草丛！", "可能会有野生宝可梦。"], color: "#ff8888", sprite: "npc_boy" }
        ],
        signs: [
            { x: 2, y: 9, text: ["PLAYER的家", "闲人免进"] },
            { x: 6, y: 12, text: ["公告板", "查看任务"], questBoard: true }
        ]
    },
    route: {
        id: 'route',
        width: 20, height: 20,
        data: [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 0,9 Exit West
            [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 0,10 Exit West
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,2,2,2,2,0,0,0,0,0,0,2,2,2,2,0,0,0,1],
            [1,0,2,2,2,2,0,0,0,0,0,0,2,2,2,2,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 0, y: 9, target: 'town', targetX: 18, targetY: 9 },
            { x: 0, y: 10, target: 'town', targetX: 18, targetY: 10 },
            { x: 19, y: 9, target: 'town2', targetX: 1, targetY: 9 },
            { x: 19, y: 10, target: 'town2', targetX: 1, targetY: 10 }
        ],
        npcs: [],
        signs: []
    },
    house: {
        id: 'house',
        width: 10, height: 10,
        data: [
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,1,1,1,3,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 5, y: 8, target: 'town', targetX: 5, targetY: 8 }
        ],
        npcs: [
             { x: 5, y: 4, text: ["这是我的房子。", "虽然很小，但是很温馨。"], color: "#eeeeee", sprite: "npc_girl" }
        ],
        signs: []
    },
    town2: {
        id: 'town2',
        width: 20, height: 20,
        data: [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], // 0,2 Route 2
            [3,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1], // 0,3 Route 2
            [1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,4,4,4,1,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,4,4,4,1,0,1,0,0,0,0,0,0,0,0,0,1], // Shop
            [1,0,0,1,4,4,4,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,1,3,1,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], // 9,0 From Route
            [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], // 10,0 From Route
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 0, y: 9, target: 'route', targetX: 18, targetY: 9 },
            { x: 0, y: 10, target: 'route', targetX: 18, targetY: 10 },
            { x: 5, y: 8, target: 'shop', targetX: 5, targetY: 7 }, // Shop Interior
            { x: 0, y: 2, target: 'route2', targetX: 18, targetY: 9 }, // To Route 2
            { x: 0, y: 3, target: 'route2', targetX: 18, targetY: 10 }
        ],
        npcs: [
            { x: 10, y: 10, text: ["这是常青市。", "记得去商店看看！"], color: "#88ccff", sprite: "npc_boy" }
        ],
        signs: [
            { x: 4, y: 8, text: ["友好商店", "欢迎光临！"] }
        ]
    },
    shop: {
        id: 'shop',
        width: 10, height: 10,
        data: [
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1], // Counter
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,1,1,1,3,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 5, y: 8, target: 'town2', targetX: 5, targetY: 9 }
        ],
        npcs: [
            { x: 5, y: 4, text: ["欢迎光临!", "想买点什么吗?"], color: "#eeeeee", sprite: "npc_boy", shop: true }
        ],
        signs: []
    },
    route2: {
        id: 'route2',
        width: 20, height: 20,
        data: [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], // North to Dungeon
            [1,1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1], // 9,1 Dungeon Entry
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 19,9 Exit to Town2
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 19,10
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 19, y: 9, target: 'town2', targetX: 1, targetY: 2 },
            { x: 19, y: 10, target: 'town2', targetX: 1, targetY: 3 },
            { x: 9, y: 1, target: 'dungeon1', targetX: 10, targetY: 18 },
            { x: 10, y: 1, target: 'dungeon1', targetX: 10, targetY: 18 }
        ],
        npcs: [],
        signs: [{ x: 5, y: 5, text: ["前方危险：常青森林"] }]
    },
    dungeon1: {
        id: 'dungeon1',
        width: 20, height: 20,
        data: [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1], // Boss Room
            [1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1],
            [1,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,1],
            [1,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,4,4,1],
            [1,4,4,1,0,1,1,1,1,1,1,1,1,1,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,4,4,4,4,4,4,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,1,1,1,1,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,0,0,0,0,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,0,1,1,0,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,0,1,1,0,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,0,0,0,0,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,1,1,1,1,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,4,4,4,4,4,4,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,1,1,1,1,1,1,1,1,1,0,1,4,4,1],
            [1,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,4,4,1],
            [1,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,1],
            [1,4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,1], // 10,18 Entrance
            [1,1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 9, y: 19, target: 'route2', targetX: 9, targetY: 2 },
            { x: 10, y: 19, target: 'route2', targetX: 10, targetY: 2 }
        ],
        npcs: [
            { x: 10, y: 3, text: ["吼！！！"], color: "#505050", sprite: "rattata", boss: true, bossId: 'onix' }
        ],
        signs: []
    }
};

const QUESTS = {
    q1: { id: 'q1', title: '捕捉练习', desc: '捕捉一只小拉达。', type: 'catch', targetId: 'rattata', count: 1, reward: { money: 200, item: 'potion', amount: 1 } },
    q2: { id: 'q2', title: '森林探险', desc: '捕捉一只绿毛虫。', type: 'catch', targetId: 'caterpie', count: 1, reward: { money: 300, item: 'ball', amount: 2 } },
    q3: { id: 'q3', title: 'BOSS挑战', desc: '打败地牢的 Boss。', type: 'boss', targetId: 'onix', count: 1, reward: { money: 1000, item: 'potion', amount: 5 } }
};

const SHOP_ITEMS = [
    { id: 'potion', price: 100 },
    { id: 'ball', price: 200 }
];

// --- Game State Management ---
const STATES = {
    OVERWORLD: 0,
    BATTLE: 1,
    DIALOGUE: 2,
    MENU: 3,
    SHOP: 4
};

// --- Input Handling ---
const Input = {
    keys: {},
    lastKeys: {},
    init() {
        window.addEventListener('keydown', e => {
            // Prevent default scrolling for arrow keys
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Enter"].indexOf(e.code) > -1) {
                e.preventDefault();
            }
            this.keys[e.key] = true;
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    },
    isDown(key) { return !!this.keys[key]; },
    isJustPressed(key) { return !!this.keys[key] && !this.lastKeys[key]; },
    update() { this.lastKeys = { ...this.keys }; }
};

// --- Game Data ---
const ITEMS = {
    potion: { name: '伤药', desc: '回复20HP', value: 20, type: 'heal' },
    ball: { name: '精灵球', desc: '尝试捕捉', value: 1.5, type: 'catch' }
};

const MOVES = {
    tackle: { name: '撞击', type: 'normal', pwr: 35, acc: 95, pp: 35 },
    scratch: { name: '抓', type: 'normal', pwr: 40, acc: 100, pp: 35 },
    growl: { name: '叫声', type: 'normal', pwr: 0, acc: 100, pp: 40, effect: 'stat', stat: 'atk', change: -1 },
    tailwhip: { name: '摇尾巴', type: 'normal', pwr: 0, acc: 100, pp: 30, effect: 'stat', stat: 'def', change: -1 },
    thundershock: { name: '电击', type: 'electric', pwr: 40, acc: 100, pp: 30, effect: 'status', status: 'par', chance: 0.3 },
    ember: { name: '火花', type: 'fire', pwr: 40, acc: 100, pp: 25, effect: 'status', status: 'brn', chance: 0.1 },
    vinewhip: { name: '藤鞭', type: 'grass', pwr: 45, acc: 100, pp: 25 },
    gust: { name: '起风', type: 'flying', pwr: 40, acc: 100, pp: 35 },
    poisonsting: { name: '毒针', type: 'poison', pwr: 15, acc: 100, pp: 35, effect: 'status', status: 'psn', chance: 0.3 },
    stringshot: { name: '吐丝', type: 'bug', pwr: 0, acc: 95, pp: 40, effect: 'stat', stat: 'spd', change: -1 },
    screech: { name: '刺耳声', type: 'normal', pwr: 0, acc: 85, pp: 40, effect: 'stat', stat: 'def', change: -2 },
    rockthrow: { name: '落石', type: 'rock', pwr: 50, acc: 90, pp: 15 }
};

const MONSTERS = {
    pikachu: { name: '皮卡丘', type: 'electric', hp: 35, atk: 55, def: 40, spd: 90, moves: ['thundershock', 'growl', 'tailwhip'], exp: 112 },
    rattata: { name: '小拉达', type: 'normal', hp: 30, atk: 56, def: 35, spd: 72, moves: ['tackle', 'tailwhip'], exp: 51 },
    pidgey: { name: '波波', type: 'flying', hp: 40, atk: 45, def: 40, spd: 56, moves: ['gust'], exp: 50 },
    caterpie: { name: '绿毛虫', type: 'bug', hp: 45, atk: 30, def: 35, spd: 45, moves: ['tackle', 'stringshot'], exp: 39 },
    onix: { name: '大岩蛇', type: 'rock', hp: 35, atk: 45, def: 160, spd: 70, moves: ['tackle', 'screech', 'rockthrow'], exp: 108 }
};

const LEVEL_RATE = (level) => Math.pow(level, 3);

function createPokemon(id, level) {
    const base = MONSTERS[id];
    const hp = Math.floor((2 * base.hp * level) / 100 + level + 10);
    return {
        id: id,
        name: base.name,
        type: base.type,
        level: level,
        maxHp: hp,
        hp: hp,
        atk: Math.floor((2 * base.atk * level) / 100 + 5),
        def: Math.floor((2 * base.def * level) / 100 + 5),
        spd: Math.floor((2 * base.spd * level) / 100 + 5),
        moves: base.moves.slice(0, 4)
            .map(m => MOVES[m] ? ({ ...MOVES[m], ppLeft: MOVES[m].pp }) : null)
            .filter(Boolean),
        exp: LEVEL_RATE(level),
        nextExp: LEVEL_RATE(level + 1),
        status: null
    };
}

// --- Classes ---

class Entity {
    constructor(x, y, isFollower = false) {
        this.gridX = x;
        this.gridY = y;
        this.x = x * TILE_SIZE;
        this.y = y * TILE_SIZE;
        this.targetX = this.x;
        this.targetY = this.y;
        this.isMoving = false;
        this.direction = 0; // 0: Down, 1: Up, 2: Left, 3: Right
        this.isFollower = isFollower;
    }

    update() {
        if (this.isMoving) {
            if (this.x < this.targetX) this.x += MOVE_SPEED;
            if (this.x > this.targetX) this.x -= MOVE_SPEED;
            if (this.y < this.targetY) this.y += MOVE_SPEED;
            if (this.y > this.targetY) this.y -= MOVE_SPEED;

            if (Math.abs(this.x - this.targetX) < MOVE_SPEED && Math.abs(this.y - this.targetY) < MOVE_SPEED) {
                this.x = this.targetX;
                this.y = this.targetY;
                this.gridX = Math.round(this.x / TILE_SIZE);
                this.gridY = Math.round(this.y / TILE_SIZE);
                this.isMoving = false;
            }
        }
    }

    tryMove(dx, dy, map) {
        if (this.isMoving) return false;

        const nextGridX = this.gridX + dx;
        const nextGridY = this.gridY + dy;

        // Map Boundaries
        if (nextGridY < 0 || nextGridY >= map.height || nextGridX < 0 || nextGridX >= map.width) return false;
        
        // Wall Collision
        const tile = map.data[nextGridY][nextGridX];
        if (tile === TILE.WALL || tile === TILE.SIGN) return false;

        // NPC Collision
        if (map.npcs.some(npc => npc.x === nextGridX && npc.y === nextGridY)) return false;

        this.targetX = nextGridX * TILE_SIZE;
        this.targetY = nextGridY * TILE_SIZE;
        this.isMoving = true;
        
        if (dy > 0) this.direction = 0;
        if (dy < 0) this.direction = 1;
        if (dx < 0) this.direction = 2;
        if (dx > 0) this.direction = 3;

        return true;
    }
}

class BattleSystem {
    constructor(game, onExit) {
        this.game = game;
        this.onExit = onExit;
        this.active = false;
        this.turn = 0; // 0:Menu, 1:Moves, 2:Bag, 3:Target, 4:Execute, 5:End
        this.log = "";
        this.playerPoke = null;
        this.enemyPoke = null;
        this.menuIndex = 0;
        this.fightIndex = 0;
        this.bagIndex = 0;
        this.flash = 0;
        this.isBoss = false;
    }

    start(enemy) {
        this.active = true;
        this.isBoss = false;
        this.turn = 0;
        this.playerPoke = this.game.player.team[0];
        this.enemyPoke = enemy;
        this.log = `野生的 ${enemy.name} 出现了!`;
        this.menuIndex = 0;
    }

    update() {
        if (this.turn === 4 || this.turn === 5) return;

        if (this.turn === 0) { // Main Menu
            if (Input.isJustPressed(KEYS.RIGHT)) this.menuIndex = Math.min(this.menuIndex + 1, 3);
            if (Input.isJustPressed(KEYS.LEFT)) this.menuIndex = Math.max(this.menuIndex - 1, 0);
            if (Input.isJustPressed(KEYS.DOWN)) this.menuIndex = Math.min(this.menuIndex + 2, 3);
            if (Input.isJustPressed(KEYS.UP)) this.menuIndex = Math.max(this.menuIndex - 2, 0);
            
            if (Input.isJustPressed(KEYS.A)) {
                if (this.menuIndex === 0) { this.turn = 1; this.fightIndex = 0; }
                else if (this.menuIndex === 1) { this.turn = 2; this.bagIndex = 0; }
                else if (this.menuIndex === 2) { this.log = "还不能换人!"; }
                else { // Run
                    if (Math.random() > 0.5 || this.playerPoke.spd > this.enemyPoke.spd) {
                         this.log = "成功逃跑!";
                         this.turn = 5;
                         setTimeout(() => this.exitBattle(), 1000);
                    } else {
                         this.log = "无法逃跑!";
                         this.executeTurn(null);
                    }
                }
            }
        } 
        else if (this.turn === 1) { // Fight Menu
            if (Input.isJustPressed(KEYS.DOWN)) this.fightIndex = Math.min(this.fightIndex + 1, this.playerPoke.moves.length - 1);
            if (Input.isJustPressed(KEYS.UP)) this.fightIndex = Math.max(this.fightIndex - 1, 0);
            if (Input.isJustPressed(KEYS.B)) this.turn = 0;
            if (Input.isJustPressed(KEYS.A)) {
                const move = this.playerPoke.moves[this.fightIndex];
                if (move.ppLeft > 0) {
                    this.executeTurn(move);
                } else {
                    this.log = "PP不足!";
                }
            }
        }
        else if (this.turn === 2) { // Bag Menu
            const items = Object.keys(this.game.player.bag);
            if (items.length === 0) {
                if (Input.isJustPressed(KEYS.B)) this.turn = 0;
                return;
            }
            if (Input.isJustPressed(KEYS.DOWN)) this.bagIndex = Math.min(this.bagIndex + 1, items.length - 1);
            if (Input.isJustPressed(KEYS.UP)) this.bagIndex = Math.max(this.bagIndex - 1, 0);
            if (Input.isJustPressed(KEYS.B)) this.turn = 0;
            if (Input.isJustPressed(KEYS.A)) {
                const itemId = items[this.bagIndex];
                this.useItem(itemId);
            }
        }
    }

    useItem(itemId) {
        const item = ITEMS[itemId];
        if (this.game.player.bag[itemId] <= 0) return;

        this.game.player.bag[itemId]--;
        if (this.game.player.bag[itemId] <= 0) delete this.game.player.bag[itemId];

        this.turn = 4;
        this.log = `使用了 ${item.name}!`;

        setTimeout(() => {
            if (item.type === 'heal') {
                const oldHp = this.playerPoke.hp;
                this.playerPoke.hp = Math.min(this.playerPoke.maxHp, this.playerPoke.hp + item.value);
                this.log = `回复了 ${this.playerPoke.hp - oldHp} 点HP!`;
                setTimeout(() => this.executeTurn(null), 1000);
            } else if (item.type === 'catch') {
                this.tryCatch(item.value);
            }
        }, 1000);
    }

    tryCatch(rateMod) {
        const hpPct = this.enemyPoke.hp / this.enemyPoke.maxHp;
        const statusBonus = this.enemyPoke.status ? 1.5 : 1;
        const chance = ((1 - hpPct) * 0.5 + 0.1) * rateMod * statusBonus;
        
        let shakes = 0;
        const interval = setInterval(() => {
            shakes++;
            this.log = `摇晃... (${shakes})`;
            if (Math.random() > chance && shakes < 3) {
                clearInterval(interval);
                this.log = "糟糕! 挣脱了!";
                setTimeout(() => this.executeTurn(null), 1500);
            } else if (shakes === 3) {
                clearInterval(interval);
                this.log = `收服了 ${this.enemyPoke.name}!`;
                this.game.player.team.push(this.enemyPoke);
                this.game.checkQuest(this.enemyPoke);
                setTimeout(() => this.exitBattle(true), 1500);
            }
        }, 800);
    }

    executeTurn(playerMove) {
        this.turn = 4;
        const max = (a,b)=>a>b?a:b;
        const enemyMove = this.enemyPoke.moves[Math.floor(Math.random() * this.enemyPoke.moves.length)];
        let first = this.playerPoke;
        let second = this.enemyPoke;
        let move1 = playerMove;
        let move2 = enemyMove;

        if (!playerMove) {
            first = this.enemyPoke;
            second = this.playerPoke;
            move1 = enemyMove;
            move2 = null;
        } else if (this.playerPoke.spd < this.enemyPoke.spd) {
             first = this.enemyPoke;
             second = this.playerPoke;
             move1 = enemyMove;
             move2 = playerMove;
        }

        const applyPreMoveStatus = (attacker) => {
            if (!attacker.status) return { canAct: true, msg: null };
            if (attacker.status === 'par') {
                if (Math.random() < 0.25) return { canAct: false, msg: `${attacker.name} 麻痹了! 动不了!` };
            }
            return { canAct: true, msg: null };
        };

        const applyStatusEndTurn = (poke) => {
            if (!poke.status || poke.hp <= 0) return null;
            if (poke.status === 'psn') {
                const dmg = max(1, Math.floor(poke.maxHp / 8));
                poke.hp = max(0, poke.hp - dmg);
                return `${poke.name} 因中毒受到了伤害!`;
            }
            if (poke.status === 'brn') {
                const dmg = max(1, Math.floor(poke.maxHp / 16));
                poke.hp = max(0, poke.hp - dmg);
                return `${poke.name} 被灼伤了!`;
            }
            return null;
        };

        const runMove = (attacker, defender, move, next) => {
            if (!move) { next(); return; }
            if (attacker.hp <= 0) { next(); return; }

            const pre = applyPreMoveStatus(attacker);
            if (!pre.canAct) {
                this.log = pre.msg;
                setTimeout(next, 900);
                return;
            }

            this.log = `${attacker.name} 使用 ${move.name}!`;
            if (move.ppLeft !== undefined) move.ppLeft--;

            setTimeout(() => {
                if (Math.random() * 100 > move.acc) {
                    this.log = "但是没打中!";
                    setTimeout(next, 1000);
                    return;
                }

                if (move.pwr > 0) {
                    const atkStat = attacker.status === 'brn' ? Math.max(1, Math.floor(attacker.atk * 0.5)) : attacker.atk;
                    let dmg = Math.floor((((2 * attacker.level / 5 + 2) * move.pwr * (atkStat / defender.def)) / 50) + 2);
                    if (Math.random() < 0.0625) { dmg *= 1.5; this.log += " 击中要害!"; }
                    defender.hp = Math.max(0, defender.hp - dmg);
                    this.flash = 10;
                } else if (move.effect === 'stat') {
                    this.log = `${defender.name} 的属性下降了!`;
                    defender[move.stat] = Math.max(1, Math.floor(defender[move.stat] * 0.8));
                } else if (move.effect === 'status') {
                    if (!defender.status && Math.random() < move.chance) {
                         defender.status = move.status;
                         if (move.status === 'par') defender.spd = Math.max(1, Math.floor(defender.spd * 0.5));
                         this.log = `${defender.name} 陷入了异常状态!`;
                    }
                }

                if (defender.hp <= 0) {
                    this.log = `${defender.name} 倒下了!`;
                    if (defender === this.enemyPoke) {
                        setTimeout(() => this.gainExp(), 1000);
                    } else {
                        setTimeout(() => {
                            this.log = "眼前一黑...";
                            setTimeout(() => this.exitBattle(), 1000);
                        }, 1000);
                    }
                } else {
                    setTimeout(next, 1000);
                }
            }, 800);
        };

        runMove(first, second, move1, () => {
             runMove(second, first, move2, () => {
                 // End-of-turn status damage (poison/burn)
                 const msgs = [applyStatusEndTurn(this.playerPoke), applyStatusEndTurn(this.enemyPoke)].filter(Boolean);
                 if (msgs.length) {
                     this.log = msgs[0];
                     if (this.playerPoke.hp <= 0) {
                         setTimeout(() => { this.log = '眼前一黑...'; setTimeout(() => this.exitBattle(), 900); }, 900);
                         return;
                     }
                     if (this.enemyPoke.hp <= 0) {
                         setTimeout(() => this.gainExp(), 900);
                         return;
                     }
                     setTimeout(() => {
                         this.turn = 0;
                         this.log = '要做什么?';
                     }, 900);
                     return;
                 }
                 this.turn = 0;
                 this.log = '要做什么?';
             });
        });
    }

    gainExp() {
        const exp = Math.floor(this.enemyPoke.exp * this.enemyPoke.level / 7);
        const money = Math.max(10, Math.floor(this.enemyPoke.level * 25 + this.enemyPoke.exp / 10));
        this.game.player.money = (this.game.player.money || 0) + money;
        this.log = `获得了 ${exp} 点经验值! 获得了 ¥${money}!`;
        this.playerPoke.exp += exp;
        
        setTimeout(() => {
            if (this.playerPoke.exp >= this.playerPoke.nextExp) {
                this.playerPoke.level++;
                this.playerPoke.nextExp = LEVEL_RATE(this.playerPoke.level + 1);
                const grow = Math.floor(Math.random() * 3) + 1;
                this.playerPoke.maxHp += grow;
                this.playerPoke.hp += grow;
                this.playerPoke.atk += 1;
                this.playerPoke.def += 1;
                this.playerPoke.spd += 1;
                this.log = `升级到了 Lv${this.playerPoke.level}!`;
            }
            setTimeout(() => this.exitBattle(true), 1500);
        }, 1000);
    }

    exitBattle(won = false) { this.active = false; this.onExit(won); }

    draw(ctx) {
        ctx.fillStyle = PALETTE.white;
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        if (this.flash > 0) {
            ctx.fillStyle = this.flash % 2 === 0 ? "#FFF" : "#000";
            ctx.fillRect(0,0, SCREEN_WIDTH, SCREEN_HEIGHT);
            this.flash--;
            return;
        }

        ctx.font = "14px 'Courier New'";
        this.drawStatus(ctx, 20, 20, this.enemyPoke);
        // Battle Sprites Draw (64x64 scaled to fit new screen)
        if (Sprites[this.enemyPoke.id]) {
            ctx.save();
            ctx.translate(200, 10);
            ctx.scale(1.5, 1.5);
            Sprites[this.enemyPoke.id](ctx, 0, 0);
            ctx.restore();
        } else {
            ctx.fillStyle = "#A040A0";
            ctx.fillRect(200, 30, 80, 60);
        }

        ctx.save();
        ctx.translate(10, 80);
        ctx.scale(1.5, 1.5);
        Sprites.pikachu_back(ctx, 0, 0);
        ctx.restore();
        this.drawStatus(ctx, 160, 140, this.playerPoke, true);

        ctx.fillStyle = PALETTE.black;
        ctx.fillRect(0, 208, SCREEN_WIDTH, 80);
        ctx.fillStyle = PALETTE.white;
        ctx.fillRect(2, 210, SCREEN_WIDTH-4, 76);
        ctx.fillStyle = PALETTE.black;
        ctx.font = "14px 'Courier New'";

        if (this.turn === 0) {
            ctx.fillText(this.log || "要做什么?", 14, 236);
            ctx.fillRect(160, 208, 160, 80);
            ctx.fillStyle = PALETTE.white;
            ctx.fillRect(162, 210, 156, 76);
            ctx.fillStyle = PALETTE.black;

            const opts = ["战斗", "背包", "精灵", "逃跑"];
            ctx.fillText(opts[0], 190, 236);
            ctx.fillText(opts[1], 270, 236);
            ctx.fillText(opts[2], 190, 264);
            ctx.fillText(opts[3], 270, 264);

            const cx = this.menuIndex % 2 === 0 ? 178 : 258;
            const cy = this.menuIndex < 2 ? 236 : 264;
            ctx.fillText(">", cx, cy);

        } else if (this.turn === 1) { // Moves
             this.playerPoke.moves.forEach((m, i) => {
                 ctx.fillText(`${m.name}`, 30, 230 + i * 16);
             });
             ctx.fillText(">", 16, 230 + (this.fightIndex * 16));
             const move = this.playerPoke.moves[this.fightIndex];
             ctx.fillText(`PP ${move.ppLeft}/${move.pp}`, 200, 236);
             ctx.fillText(`Type/${move.type}`, 200, 256);
        } else if (this.turn === 2) { // Bag
             const items = Object.keys(this.game.player.bag);
             if (items.length === 0) ctx.fillText("背包是空的!", 14, 236);
             else {
                 items.forEach((id, i) => {
                     const item = ITEMS[id];
                     ctx.fillText(`${item.name} x${this.game.player.bag[id]}`, 30, 230 + i * 16);
                 });
                 ctx.fillText(">", 16, 230 + (this.bagIndex * 16));
             }
        } else {
             ctx.fillText(this.log, 14, 236);
        }
    }

    drawStatus(ctx, x, y, poke, showNum) {
        ctx.fillStyle = PALETTE.black;
        ctx.font = "14px 'Courier New'";
        ctx.fillText(poke.name, x, y);
        ctx.fillText(":L" + poke.level, x + 80, y);
        if (poke.status) ctx.fillText(poke.status.toUpperCase(), x + 120, y);

        ctx.strokeRect(x, y + 8, 120, 8);
        const pct = poke.hp / poke.maxHp;
        ctx.fillStyle = pct > 0.5 ? "#50C050" : pct > 0.2 ? "#F0C030" : "#F04040";
        ctx.fillRect(x + 1, y + 9, Math.max(0, 118 * pct), 6);

        if (showNum) {
             ctx.fillStyle = PALETTE.black;
             ctx.fillText(`${poke.hp}/${poke.maxHp}`, x + 30, y + 30);
             ctx.fillStyle = "#4040FF";
             const expPct = (poke.exp - LEVEL_RATE(poke.level)) / (poke.nextExp - LEVEL_RATE(poke.level));
             ctx.fillRect(x, y + 34, 120 * Math.max(0, expPct), 4);
        }
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.ctx.imageSmoothingEnabled = false;
        Input.init();

        // State
        this.currentMapId = 'town';
        this.currentMap = MAPS['town'];
        
        this.player = new Entity(10, 10);
        this.player.team = [createPokemon('pikachu', 5)];
        this.player.bag = { potion: 1 };
        this.player.money = 500;
        this.player.quests = { active: [], completed: [] }; // Stores quest IDs

        this.pikachu = new Entity(10, 11, true);
        this.pikachu.direction = 1; 

        this.gameState = STATES.OVERWORLD;
        this.battle = new BattleSystem(this, (won) => { 
            this.gameState = STATES.OVERWORLD; 
            if (won && this.battle.isBoss) {
                this.player.quests.bossDefeated = true;
                this.showDialogue(["BOSS被击败了!", "任务进度已更新。"]);
            }
        });

        // Dialogue
        this.dialogueQueue = [];
        this.currentText = "";
        this.targetText = "";
        this.charIndex = 0;
        this.textSpeed = 1;
        this.textTimer = 0;

        // Menu
        this.menuOptions = ["队伍", "背包", "保存", "关闭"];
        this.menuIndex = 0;
        this.menuState = 0; // 0: Main, 1: Submenu

        // Camera
        this.camX = 0;
        this.camY = 0;
        
        this.frameCount = 0;

        // Load
        this.loadGame();

        this.lastTime = 0;
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    loadGame() {
        const save = localStorage.getItem('pokemon_canvas_save');
        if (save) {
            const data = JSON.parse(save);
            this.currentMapId = data.mapId;
            this.currentMap = MAPS[data.mapId];
            this.player.x = data.x;
            this.player.y = data.y;
            this.player.gridX = Math.round(data.x / TILE_SIZE);
            this.player.gridY = Math.round(data.y / TILE_SIZE);
            this.player.targetX = this.player.x;
            this.player.targetY = this.player.y;
            
            if (data.team) this.player.team = data.team;
            if (data.bag) this.player.bag = data.bag;
            if (data.quests) this.player.quests = data.quests;
            if (data.money) this.player.money = data.money;

            // Reset pikachu
            this.pikachu.x = this.player.x;
            this.pikachu.y = this.player.y + TILE_SIZE;
            this.pikachu.gridX = this.player.gridX;
            this.pikachu.gridY = this.player.gridY + 1;
            this.pikachu.targetX = this.pikachu.x;
            this.pikachu.targetY = this.pikachu.y;
        }
    }

    saveGame() {
        const data = {
            mapId: this.currentMapId,
            x: this.player.x,
            y: this.player.y,
            team: this.player.team,
            bag: this.player.bag,
            quests: this.player.quests,
            money: this.player.money
        };
        localStorage.setItem('pokemon_canvas_save', JSON.stringify(data));
        this.showDialogue(["游戏已保存。"]);
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;
        this.frameCount++;
        this.update();
        this.draw();
        Input.update();
        requestAnimationFrame(this.loop);
    }

    update() {
        if (this.gameState === STATES.OVERWORLD) this.updateOverworld();
        else if (this.gameState === STATES.BATTLE) this.battle.update();
        else if (this.gameState === STATES.DIALOGUE) this.updateDialogue();
        else if (this.gameState === STATES.MENU) this.updateMenu();
    }

    updateOverworld() {
        // Open Menu
        if (Input.isJustPressed(KEYS.START)) {
            this.gameState = STATES.MENU;
            this.menuIndex = 0;
            this.menuState = 0;
            return;
        }

        // Interaction
        if (Input.isJustPressed(KEYS.A)) {
            this.checkInteraction();
            return;
        }

        // Movement
        let dx = 0, dy = 0;
        if (!this.player.isMoving) {
            if (Input.isDown(KEYS.UP)) dy = -1;
            else if (Input.isDown(KEYS.DOWN)) dy = 1;
            else if (Input.isDown(KEYS.LEFT)) dx = -1;
            else if (Input.isDown(KEYS.RIGHT)) dx = 1;

            if (dx !== 0 || dy !== 0) {
                const prevX = this.player.gridX;
                const prevY = this.player.gridY;
                
                if (this.player.tryMove(dx, dy, this.currentMap)) {
                    // Move Pikachu
                    this.pikachu.targetX = prevX * TILE_SIZE;
                    this.pikachu.targetY = prevY * TILE_SIZE;
                    this.pikachu.gridX = prevX;
                    this.pikachu.gridY = prevY;
                    this.pikachu.isMoving = true;
                    if (this.player.gridY < prevY) this.pikachu.direction = 1;
                    if (this.player.gridY > prevY) this.pikachu.direction = 0;
                    if (this.player.gridX < prevX) this.pikachu.direction = 2;
                    if (this.player.gridX > prevX) this.pikachu.direction = 3;

                    // Grass Check
                    if (this.currentMap.data[this.player.gridY][this.player.gridX] === TILE.GRASS) {
                        if (Math.random() < 0.15) this.triggerBattleNext = true;
                    }
                } else {
                    // Turn
                    if (dy > 0) this.player.direction = 0;
                    if (dy < 0) this.player.direction = 1;
                    if (dx < 0) this.player.direction = 2;
                    if (dx > 0) this.player.direction = 3;
                }
            }
        }

        this.player.update();
        this.pikachu.update();

        // Portal Check
        if (!this.player.isMoving && !this.triggerBattleNext) {
            const portal = this.currentMap.portals.find(p => p.x === this.player.gridX && p.y === this.player.gridY);
            if (portal) this.switchMap(portal);
        }

        if (this.triggerBattleNext && !this.player.isMoving) {
            // Only trigger encounter if we're still on encounter tile (grass)
            const onGrass = this.currentMap.data[this.player.gridY][this.player.gridX] === TILE.GRASS;
            if (!onGrass) { this.triggerBattleNext = false; }
            if (onGrass) {
                this.triggerBattleNext = false;
                this.gameState = STATES.BATTLE;
                const ids = ['rattata', 'pidgey', 'caterpie'];
                const id = ids[Math.floor(Math.random() * ids.length)];
                const lvl = Math.max(2, Math.floor(this.player.team[0].level - 1 + Math.random() * 3));
                this.battle.start(createPokemon(id, lvl));
            }
        }

        this.updateCamera();
    }

    updateCamera() {
        const targetCamX = this.player.x - SCREEN_WIDTH / 2 + TILE_SIZE / 2;
        const targetCamY = this.player.y - SCREEN_HEIGHT / 2 + TILE_SIZE / 2;
        this.camX += (targetCamX - this.camX) * 0.1;
        this.camY += (targetCamY - this.camY) * 0.1;
        this.camX = Math.max(0, Math.min(this.camX, (this.currentMap.width * TILE_SIZE) - SCREEN_WIDTH));
        this.camY = Math.max(0, Math.min(this.camY, (this.currentMap.height * TILE_SIZE) - SCREEN_HEIGHT));
    }

    switchMap(portal) {
        // prevent cross-map encounter carry-over
        this.triggerBattleNext = false;
        this.currentMapId = portal.target;
        this.currentMap = MAPS[portal.target];
        this.player.gridX = portal.targetX;
        this.player.gridY = portal.targetY;
        this.player.x = portal.targetX * TILE_SIZE;
        this.player.y = portal.targetY * TILE_SIZE;
        this.player.targetX = this.player.x;
        this.player.targetY = this.player.y;
        
        // Reset Pikachu nearby
        this.pikachu.gridX = portal.targetX;
        this.pikachu.gridY = portal.targetY; 
        this.pikachu.x = this.player.x;
        this.pikachu.y = this.player.y;
        this.pikachu.targetX = this.pikachu.x;
        this.pikachu.targetY = this.pikachu.y;
        this.pikachu.isMoving = false;
        
        this.camX = this.player.x - SCREEN_WIDTH/2; 
        this.camY = this.player.y - SCREEN_HEIGHT/2;
    }

    checkInteraction() {
        const dx = [0, 0, -1, 1][this.player.direction];
        const dy = [1, -1, 0, 0][this.player.direction];
        const tx = this.player.gridX + dx;
        const ty = this.player.gridY + dy;

        // Check NPCs
        const npc = this.currentMap.npcs.find(n => n.x === tx && n.y === ty);
        if (npc) {
            if (npc.boss) {
                if (this.player.quests.bossDefeated) {
                    this.showDialogue(["(大岩蛇已经倒下了)"]);
                } else {
                    this.showDialogue(["吼！！！"]);
                    setTimeout(() => {
                        this.gameState = STATES.BATTLE;
                        this.battle.isBoss = true;
                        this.battle.start(createPokemon('onix', 10));
                    }, 1000);
                }
                return;
            }
            if (npc.shop) {
                this.gameState = STATES.MENU; // Use Menu state for simplicity, or create custom SHOP state
                this.menuState = 4; // 4: Shop
                this.menuIndex = 0;
                return;
            }
            this.showDialogue(npc.text);
            return;
        }

        // Check Signs
        const sign = this.currentMap.signs.find(s => s.x === tx && s.y === ty);
        if (sign) {
            if (sign.text[0] === "公告板") {
                 const qId = Object.keys(QUESTS).find(id => !this.player.quests.completed.includes(id));
                 if (!qId) {
                     this.showDialogue(["所有任务已完成！"]);
                     return;
                 }
                 const q = QUESTS[qId];
                 const isActive = this.player.quests.active.includes(qId);
                 
                 if (isActive) {
                     let done = false;
                     if (q.type === 'catch') {
                         const count = this.player.team.filter(p => p.id === q.targetId).length;
                         if (count >= q.count) done = true;
                     } else if (q.type === 'boss') {
                         if (this.player.quests.bossDefeated) done = true;
                     }

                     if (done) {
                         this.player.quests.active = this.player.quests.active.filter(id => id !== qId);
                         this.player.quests.completed.push(qId);
                         this.player.money += q.reward.money;
                         if (q.reward.item) this.player.bag[q.reward.item] = (this.player.bag[q.reward.item] || 0) + q.reward.amount;
                         this.showDialogue([`完成任务: ${q.title}!`, `获得 ¥${q.reward.money}`]);
                     } else {
                         this.showDialogue([`进行中: ${q.title}`, q.desc]);
                     }
                 } else {
                     this.player.quests.active.push(qId);
                     this.showDialogue([`接受任务: ${q.title}`, q.desc]);
                 }
                 return;
            }
            this.showDialogue(sign.text);
            return;
        }
    }
    
    checkQuest(caughtPoke) {
        // Triggered inside BattleSystem
    }

    showDialogue(lines) {
        this.dialogueQueue = [...lines];
        this.gameState = STATES.DIALOGUE;
        this.nextDialogueLine();
    }

    nextDialogueLine() {
        if (this.dialogueQueue.length === 0) {
            this.gameState = STATES.OVERWORLD;
            return;
        }
        this.targetText = this.dialogueQueue.shift();
        this.currentText = "";
        this.charIndex = 0;
    }

    updateDialogue() {
        if (Input.isJustPressed(KEYS.B)) this.textSpeed = 3; // Speed up
        else this.textSpeed = 1;

        if (this.charIndex < this.targetText.length) {
            this.textTimer += this.textSpeed;
            if (this.textTimer >= 2) {
                this.charIndex++;
                this.currentText = this.targetText.substring(0, this.charIndex);
                this.textTimer = 0;
            }
        } else {
            // Wait for input
            if (Input.isJustPressed(KEYS.A)) {
                this.nextDialogueLine();
            }
        }
    }

    updateMenu() {
        if (this.menuState === 0) {
            if (Input.isJustPressed(KEYS.B)) {
                this.gameState = STATES.OVERWORLD;
            }
            if (Input.isJustPressed(KEYS.UP)) this.menuIndex = Math.max(0, this.menuIndex - 1);
            if (Input.isJustPressed(KEYS.DOWN)) this.menuIndex = Math.min(this.menuOptions.length - 1, this.menuIndex + 1);
            
            if (Input.isJustPressed(KEYS.A)) {
                const selection = this.menuOptions[this.menuIndex];
                if (selection === "关闭") this.gameState = STATES.OVERWORLD;
                else if (selection === "保存") {
                    this.saveGame();
                }
                else if (selection === "队伍") {
                    this.menuState = 1; // Show Team
                }
                else if (selection === "背包") {
                    this.menuState = 2; // Show Bag
                }
            }
        } else if (this.menuState === 4) { // Shop
             if (Input.isJustPressed(KEYS.B)) this.gameState = STATES.OVERWORLD;
             if (Input.isJustPressed(KEYS.UP)) this.menuIndex = Math.max(0, this.menuIndex - 1);
             if (Input.isJustPressed(KEYS.DOWN)) this.menuIndex = Math.min(SHOP_ITEMS.length - 1, this.menuIndex + 1);
             
             if (Input.isJustPressed(KEYS.A)) {
                 const itemData = SHOP_ITEMS[this.menuIndex];
                 if (this.player.money >= itemData.price) {
                     this.player.money -= itemData.price;
                     this.player.bag[itemData.id] = (this.player.bag[itemData.id] || 0) + 1;
                     // Optional: Feedback sound or visual
                 }
             }
        } else {
             if (Input.isJustPressed(KEYS.B)) this.menuState = 0;
        }
    }

    draw() {
        this.ctx.fillStyle = PALETTE.black;
        this.ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        if (this.gameState === STATES.BATTLE) {
            this.battle.draw(this.ctx);
            return;
        }

        this.ctx.save();
        this.ctx.translate(-Math.floor(this.camX), -Math.floor(this.camY));

        // Map
        const map = this.currentMap;
        for (let y = 0; y < map.height; y++) {
            for (let x = 0; x < map.width; x++) {
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                if (px < this.camX - TILE_SIZE || px > this.camX + SCREEN_WIDTH ||
                    py < this.camY - TILE_SIZE || py > this.camY + SCREEN_HEIGHT) continue;
                
                const t = map.data[y][x];

                // Use procedural high-detail sprites (CC0 tiles disabled)
                // const drew = Assets.loaded && Assets.drawTile(this.ctx, t, px, py);
                // if (drew) continue;

                if (t === TILE.WALL) Sprites.wall(this.ctx, px, py);
                else if (t === TILE.GRASS) {
                    this.ctx.fillStyle = PALETTE.white;
                    this.ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    Sprites.grass(this.ctx, px, py);
                }
                else if (t === TILE.FLOOR) Sprites.floor(this.ctx, px, py);
                else if (t === TILE.DOOR) Sprites.door(this.ctx, px, py);
                else if (t === TILE.SIGN) {
                    this.ctx.fillStyle = PALETTE.white;
                    this.ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    Sprites.sign(this.ctx, px, py);
                }
                else {
                    this.ctx.fillStyle = PALETTE.white;
                    this.ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        // Entities & NPCs (Z-Sorted)
        const renderList = [];
        
        // Player
        renderList.push({
            y: this.player.y,
            draw: () => Sprites.player.draw(this.ctx, this.player.x, this.player.y, this.frameCount, this.player.direction)
        });

        // Pikachu
        renderList.push({
            y: this.pikachu.y,
            draw: () => Sprites.pikachu.draw(this.ctx, this.pikachu.x, this.pikachu.y, this.frameCount, this.pikachu.direction)
        });

        // NPCs
        map.npcs.forEach(n => {
            const spriteId = n.sprite || 'npc';
            const drawer = Sprites[spriteId] || Sprites.npc;
            renderList.push({
                y: n.y * TILE_SIZE,
                draw: () => drawer.draw(this.ctx, n.x * TILE_SIZE, n.y * TILE_SIZE, n.color)
            });
        });

        renderList.sort((a, b) => a.y - b.y);
        renderList.forEach(r => r.draw());

        this.ctx.restore();

        // UI Layer
        if (this.gameState === STATES.DIALOGUE) this.drawDialogue();
        if (this.gameState === STATES.MENU) this.drawMenu();
    }

    drawDialogue() {
        this.ctx.fillStyle = PALETTE.black;
        this.ctx.fillRect(0, 208, SCREEN_WIDTH, 80);
        this.ctx.fillStyle = PALETTE.white;
        this.ctx.fillRect(2, 210, SCREEN_WIDTH-4, 76);
        this.ctx.fillStyle = PALETTE.black;
        this.ctx.font = "14px 'Courier New'";
        this.ctx.fillText(this.currentText, 14, 242);

        if (this.charIndex >= this.targetText.length) {
            // Blink arrow
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                 this.ctx.fillText("▼", 296, 276);
            }
        }
    }

    drawMenu() {
        this.ctx.font = "14px 'Courier New'";
        if (this.menuState === 0) {
            const boxW = 140;
            const boxH = this.menuOptions.length * 22 + 40;
            const startX = SCREEN_WIDTH - boxW - 4;
            const startY = 4;

            this.ctx.fillStyle = PALETTE.white;
            this.ctx.fillRect(startX, startY, boxW, boxH);
            this.ctx.strokeStyle = PALETTE.black;
            this.ctx.strokeRect(startX, startY, boxW, boxH);

            this.ctx.fillStyle = PALETTE.black;

            this.menuOptions.forEach((opt, i) => {
                this.ctx.fillText(opt, startX + 26, startY + 22 + (i * 22));
            });

            this.ctx.fillText(">", startX + 10, startY + 22 + (this.menuIndex * 22));

            // Draw Money
            this.ctx.fillStyle = "#306850";
            this.ctx.fillText(`¥${this.player.money}`, startX + 10, startY + boxH - 8);
        } else if (this.menuState === 1) { // Team
            this.ctx.fillStyle = PALETTE.white;
            this.ctx.fillRect(20, 20, 280, 240);
            this.ctx.strokeRect(20, 20, 280, 240);
            this.ctx.fillStyle = PALETTE.black;
            this.ctx.fillText("队伍 (按X返回)", 30, 44);

            this.player.team.forEach((poke, i) => {
                 this.ctx.fillText(`${poke.name} Lv${poke.level} ${poke.hp}/${poke.maxHp}`, 30, 70 + i * 24);
            });
        } else if (this.menuState === 2) { // Bag
            this.ctx.fillStyle = PALETTE.white;
            this.ctx.fillRect(20, 20, 280, 240);
            this.ctx.strokeRect(20, 20, 280, 240);
            this.ctx.fillStyle = PALETTE.black;
            this.ctx.fillText("背包 (按X返回)", 30, 44);

            const items = Object.keys(this.player.bag);
             if (items.length === 0) this.ctx.fillText("背包是空的", 30, 70);
             else {
                 items.forEach((id, i) => {
                     const item = ITEMS[id];
                     this.ctx.fillText(`${item.name} x${this.player.bag[id]}`, 30, 70 + i * 24);
                 });
             }
        } else if (this.menuState === 4) { // Shop
            this.ctx.fillStyle = PALETTE.white;
            this.ctx.fillRect(20, 20, 280, 240);
            this.ctx.strokeRect(20, 20, 280, 240);
            this.ctx.fillStyle = PALETTE.black;
            this.ctx.fillText("商店 (按X离开)", 30, 44);
            this.ctx.fillText(`¥${this.player.money}`, 200, 44);

            SHOP_ITEMS.forEach((itemData, i) => {
                const name = ITEMS[itemData.id].name;
                this.ctx.fillText(`${name}`, 50, 76 + i * 24);
                this.ctx.fillText(`¥${itemData.price}`, 200, 76 + i * 24);
                if (i === this.menuIndex) this.ctx.fillText(">", 34, 76 + i * 24);
            });
        }
    }
}

window.onload = async () => {
    // Show a simple loading screen while preloading CC0 tiles.
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = '#202020';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#e0f8cf';
    ctx.font = '14px monospace';
    ctx.fillText('Loading assets...', 100, 144);

    try { await Assets.preload(); } catch (e) { /* ignore, fallback sprites still work */ }
    window.__game = new Game();
};

</script>
</body>
</html>
