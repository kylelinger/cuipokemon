<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokemon Yellow Remake (Canvas)</title>
    <!--
      CC0 Art Attribution:
      Overworld tiles are from Kenney "Tiny Town" (CC0): https://kenney.nl/assets/tiny-town
      License file included in this repo at: assets/cc0/tiny-town/License.txt
    -->
    <style>
        body {
            background-color: #202020;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            color: white;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 480px;
            height: 432px; /* 160x144 * 3 */
            background-color: #9bbc0f;
            border: 10px solid #505050;
            border-radius: 10px 10px 40px 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            image-rendering: pixelated;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .controls-hint {
            margin-top: 20px;
            text-align: center;
            color: #aaa;
            font-size: 14px;
        }

        .key {
            background: #444;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #666;
            color: #fff;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="160" height="144"></canvas>
    </div>

    <div class="controls-hint">
        <p>控制: <span class="key">方向键</span> 移动 | <span class="key">Enter</span> 菜单</p>
        <p><span class="key">Z</span> 确定/互动 | <span class="key">X</span> 取消/加速</p>
    </div>

<script>
/**
 * POKEMON YELLOW WEB REMAKE - Phase 1 Enhanced
 */

// --- Constants & Config ---
const TILE_SIZE = 16;
const SCREEN_WIDTH = 160;
const SCREEN_HEIGHT = 144;
const FPS = 60;
const MOVE_SPEED = 1.6; // slowed by 20%

const PALETTE = {
    white: "#e0f8cf",
    light: "#86c06c",
    dark: "#306850",
    black: "#071821"
};

const KEYS = {
    UP: 'ArrowUp',
    DOWN: 'ArrowDown',
    LEFT: 'ArrowLeft',
    RIGHT: 'ArrowRight',
    A: 'z',
    B: 'x',
    START: 'Enter'
};

const TILE = {
    WALK: 0,
    WALL: 1,
    GRASS: 2,
    DOOR: 3,
    FLOOR: 4,
    SIGN: 5
};

// --- Assets ---
// Tile atlas (Kenney Tiny Town, 16x16)
const TILE_ATLAS = {
    [TILE.WALK]:  'assets/cc0/tiny-town/Tiles/tile_0000.png',
    [TILE.GRASS]: 'assets/cc0/tiny-town/Tiles/tile_0036.png',
    [TILE.WALL]:  'assets/cc0/tiny-town/Tiles/tile_0082.png',
    [TILE.FLOOR]: 'assets/cc0/tiny-town/Tiles/tile_0020.png',
    [TILE.DOOR]:  'assets/cc0/tiny-town/Tiles/tile_0108.png',
    [TILE.SIGN]:  'assets/cc0/tiny-town/Tiles/tile_0120.png'
};

const Assets = {
    tiles: new Map(),
    loaded: false,
    async preload() {
        const entries = Object.entries(TILE_ATLAS);
        const promises = entries.map(([tileId, src]) => new Promise((resolve) => {
            const img = new Image();
            img.onload = () => resolve([Number(tileId), img]);
            img.onerror = () => resolve([Number(tileId), null]);
            img.src = src;
        }));
        const results = await Promise.all(promises);
        results.forEach(([tileId, img]) => { if (img) this.tiles.set(tileId, img); });
        this.loaded = true;
    },
    drawTile(ctx, tileId, x, y) {
        const img = this.tiles.get(tileId);
        if (img) {
            try {
                ctx.drawImage(img, x, y, TILE_SIZE, TILE_SIZE);
                return true;
            } catch (e) {
                // If draw fails (e.g. img not fully loaded), fallback will run
                return false;
            }
        }
        return false;
    }
};

const Sprites = {
    player: {
        draw: (ctx, x, y, frame, dir) => {
            ctx.fillStyle = PALETTE.black;
            ctx.fillRect(x+2, y+14, 12, 2); // Shadow
            // Body - Blue Shirt, Black Pants
            ctx.fillStyle = "#306850"; // Shirt
            ctx.fillRect(x+4, y+6, 8, 6);
            ctx.fillStyle = "#071821"; // Pants
            ctx.fillRect(x+4, y+12, 8, 3);
            // Head - Cap
            ctx.fillStyle = "#FF3333"; // Hat
            ctx.fillRect(x+3, y+1, 10, 3);
            ctx.fillStyle = "#FFF"; // Visor
            ctx.fillRect(x+4, y+4, 8, 2);
            // Animation (Walk)
            if (frame && Math.floor(frame / 10) % 2 === 0) {
                 ctx.fillStyle = "#071821";
                 ctx.fillRect(x+4, y+15, 3, 1);
                 ctx.fillRect(x+9, y+15, 3, 1);
            }
        }
    },
    pikachu: {
        draw: (ctx, x, y, frame, dir) => {
            ctx.fillStyle = "#663300"; // Tail
            ctx.fillRect(x+10, y+4, 4, 2);
            ctx.fillStyle = "#FFCC00"; 
            ctx.fillRect(x+10, y+6, 2, 4);
            ctx.fillStyle = "#FFCC00"; // Body
            ctx.fillRect(x+3, y+6, 10, 8);
            ctx.fillStyle = "#000"; // Ears
            ctx.fillRect(x+3, y+2, 2, 2);
            ctx.fillRect(x+11, y+2, 2, 2);
            ctx.fillStyle = "#FFCC00";
            ctx.fillRect(x+3, y+4, 2, 2);
            ctx.fillRect(x+11, y+4, 2, 2);
            ctx.fillStyle = "#FF0000"; // Cheeks
            ctx.fillRect(x+4, y+9, 2, 2);
            ctx.fillRect(x+10, y+9, 2, 2);
        }
    },
    // Distinct NPC Sprites
    npc_boy: {
        draw: (ctx, x, y, color) => {
            ctx.fillStyle = PALETTE.black; // Shadow
            ctx.fillRect(x+2, y+14, 12, 2);
            ctx.fillStyle = color || "#88ccff"; // Shirt
            ctx.fillRect(x+4, y+6, 8, 6);
            ctx.fillStyle = "#303080"; // Pants
            ctx.fillRect(x+4, y+12, 8, 3);
            ctx.fillStyle = "#ffe0c0"; // Face
            ctx.fillRect(x+4, y+2, 8, 4);
            ctx.fillStyle = "#504030"; // Hair
            ctx.fillRect(x+4, y+1, 8, 2);
        }
    },
    npc_girl: {
        draw: (ctx, x, y, color) => {
            ctx.fillStyle = PALETTE.black; // Shadow
            ctx.fillRect(x+2, y+14, 12, 2);
            ctx.fillStyle = color || "#ff8888"; // Dress
            ctx.fillRect(x+4, y+6, 8, 8);
            ctx.fillStyle = "#ffe0c0"; // Face
            ctx.fillRect(x+4, y+2, 8, 4);
            ctx.fillStyle = "#602020"; // Hair
            ctx.fillRect(x+3, y+1, 10, 3);
            // Pigtails
            ctx.fillStyle = "#602020";
            ctx.fillRect(x+1, y+3, 2, 4);
            ctx.fillRect(x+13, y+3, 2, 4);
        }
    },
    // Fallback/Generic NPC
    npc: {
        draw: (ctx, x, y, color) => {
            ctx.fillStyle = PALETTE.black;
            ctx.fillRect(x+2, y+14, 12, 2);
            ctx.fillStyle = color || "#88ccff";
            ctx.fillRect(x+4, y+4, 8, 10);
            ctx.fillStyle = PALETTE.white;
            ctx.fillRect(x+5, y+5, 6, 3);
        }
    },
    grass: (ctx, x, y) => {
        ctx.fillStyle = "#609050";
        ctx.fillRect(x, y, 16, 16);
        ctx.fillStyle = "#306850";
        ctx.fillRect(x+2, y+4, 2, 4);
        ctx.fillRect(x+6, y+8, 2, 4);
        ctx.fillRect(x+10, y+3, 2, 4);
        ctx.fillRect(x+12, y+10, 2, 4);
    },
    wall: (ctx, x, y) => {
        ctx.fillStyle = "#306850";
        ctx.fillRect(x, y, 16, 16);
        ctx.strokeStyle = "#071821";
        ctx.strokeRect(x, y, 16, 16);
        ctx.fillStyle = "#071821";
        ctx.fillRect(x, y+7, 16, 1);
        ctx.fillRect(x+7, y, 1, 7);
        ctx.fillRect(x+3, y+8, 1, 8);
    },
    floor: (ctx, x, y) => {
        ctx.fillStyle = "#D0D0C0";
        ctx.fillRect(x, y, 16, 16);
        ctx.fillStyle = "#A0A090";
        ctx.fillRect(x+2, y+2, 12, 12);
    },
    door: (ctx, x, y) => {
        ctx.fillStyle = "#000";
        ctx.fillRect(x, y, 16, 16);
    },
    sign: (ctx, x, y) => {
        ctx.fillStyle = "#8B4513"; // Wood
        ctx.fillRect(x+2, y+2, 12, 10);
        ctx.fillStyle = "#e0f8cf"; // Paper
        ctx.fillRect(x+4, y+4, 8, 6);
        ctx.fillStyle = "#000"; // Text
        ctx.fillRect(x+5, y+5, 6, 1);
        ctx.fillRect(x+5, y+7, 4, 1);
        ctx.fillStyle = "#8B4513"; // Post
        ctx.fillRect(x+7, y+12, 2, 4);
    },
    rattata: (ctx, x, y) => {
        ctx.fillStyle = "#A040A0";
        ctx.fillRect(x+20, y+20, 40, 30);
        ctx.fillRect(x+15, y+10, 10, 15); // Ears
        ctx.fillRect(x+55, y+10, 10, 15);
        ctx.fillStyle = "#FFF"; // Eyes
        ctx.fillRect(x+25, y+25, 8, 8);
        ctx.fillRect(x+45, y+25, 8, 8);
        ctx.fillStyle = "#000";
        ctx.fillRect(x+27, y+27, 2, 2);
        ctx.fillRect(x+47, y+27, 2, 2);
    },
    pikachu_back: (ctx, x, y) => {
        ctx.fillStyle = "#FFCC00";
        ctx.fillRect(x+10, y+20, 40, 40);
        ctx.fillStyle = "#000"; // Ears
        ctx.fillRect(x+5, y+5, 10, 15);
        ctx.fillRect(x+45, y+5, 10, 15);
        ctx.fillStyle = "#FFCC00";
        ctx.fillRect(x+5, y+15, 10, 10);
        ctx.fillRect(x+45, y+15, 10, 10);
        ctx.fillStyle = "#663300"; // Tail
        ctx.fillRect(x+50, y+30, 10, 5);
        ctx.fillRect(x+55, y+20, 10, 20);
    }
};

// --- Map Data ---
const MAPS = {
    town: {
        id: 'town',
        width: 20, height: 20,
        data: [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,4,4,4,1,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,4,4,4,1,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,4,4,4,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,1,3,1,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 19,9 Exit East
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 19,10 Exit East
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 5, y: 7, target: 'house', targetX: 5, targetY: 8 },
            { x: 19, y: 9, target: 'route', targetX: 1, targetY: 9 },
            { x: 19, y: 10, target: 'route', targetX: 1, targetY: 10 }
        ],
        npcs: [
            { x: 8, y: 12, text: ["你好！", "这里是真新镇。"], color: "#88ccff", sprite: "npc_girl" },
            { x: 14, y: 6, text: ["小心草丛！", "可能会有野生宝可梦。"], color: "#ff8888", sprite: "npc_boy" }
        ],
        signs: [
            { x: 2, y: 9, text: ["PLAYER的家", "闲人免进"] },
            { x: 6, y: 12, text: ["公告板", "查看任务"], questBoard: true }
        ]
    },
    route: {
        id: 'route',
        width: 20, height: 20,
        data: [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 0,9 Exit West
            [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 0,10 Exit West
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,2,2,2,2,0,0,0,0,0,0,2,2,2,2,0,0,0,1],
            [1,0,2,2,2,2,0,0,0,0,0,0,2,2,2,2,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 0, y: 9, target: 'town', targetX: 18, targetY: 9 },
            { x: 0, y: 10, target: 'town', targetX: 18, targetY: 10 },
            { x: 19, y: 9, target: 'town2', targetX: 1, targetY: 9 },
            { x: 19, y: 10, target: 'town2', targetX: 1, targetY: 10 }
        ],
        npcs: [],
        signs: []
    },
    house: {
        id: 'house',
        width: 10, height: 10,
        data: [
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,1,1,1,3,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 5, y: 8, target: 'town', targetX: 5, targetY: 8 }
        ],
        npcs: [
             { x: 5, y: 4, text: ["这是我的房子。", "虽然很小，但是很温馨。"], color: "#eeeeee", sprite: "npc_girl" }
        ],
        signs: []
    },
    town2: {
        id: 'town2',
        width: 20, height: 20,
        data: [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
            [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], // 0,2 Route 2
            [3,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1], // 0,3 Route 2
            [1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,4,4,4,1,0,1,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,4,4,4,1,0,1,0,0,0,0,0,0,0,0,0,1], // Shop
            [1,0,0,1,4,4,4,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,1,1,3,1,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], // 9,0 From Route
            [3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], // 10,0 From Route
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 0, y: 9, target: 'route', targetX: 18, targetY: 9 },
            { x: 0, y: 10, target: 'route', targetX: 18, targetY: 10 },
            { x: 5, y: 8, target: 'shop', targetX: 5, targetY: 7 }, // Shop Interior
            { x: 0, y: 2, target: 'route2', targetX: 18, targetY: 9 }, // To Route 2
            { x: 0, y: 3, target: 'route2', targetX: 18, targetY: 10 }
        ],
        npcs: [
            { x: 10, y: 10, text: ["这是常青市。", "记得去商店看看！"], color: "#88ccff", sprite: "npc_boy" }
        ],
        signs: [
            { x: 4, y: 8, text: ["友好商店", "欢迎光临！"] }
        ]
    },
    shop: {
        id: 'shop',
        width: 10, height: 10,
        data: [
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1], // Counter
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,4,4,4,4,4,4,1,1],
            [1,1,1,1,1,3,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 5, y: 8, target: 'town2', targetX: 5, targetY: 9 }
        ],
        npcs: [
            { x: 5, y: 4, text: ["欢迎光临!", "想买点什么吗?"], color: "#eeeeee", sprite: "npc_boy", shop: true }
        ],
        signs: []
    },
    route2: {
        id: 'route2',
        width: 20, height: 20,
        data: [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], // North to Dungeon
            [1,1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1], // 9,1 Dungeon Entry
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 19,9 Exit to Town2
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3], // 19,10
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,1],
            [1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 19, y: 9, target: 'town2', targetX: 1, targetY: 2 },
            { x: 19, y: 10, target: 'town2', targetX: 1, targetY: 3 },
            { x: 9, y: 1, target: 'dungeon1', targetX: 10, targetY: 18 },
            { x: 10, y: 1, target: 'dungeon1', targetX: 10, targetY: 18 }
        ],
        npcs: [],
        signs: [{ x: 5, y: 5, text: ["前方危险：常青森林"] }]
    },
    dungeon1: {
        id: 'dungeon1',
        width: 20, height: 20,
        data: [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1], // Boss Room
            [1,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,1],
            [1,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,1],
            [1,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,4,4,1],
            [1,4,4,1,0,1,1,1,1,1,1,1,1,1,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,4,4,4,4,4,4,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,1,1,1,1,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,0,0,0,0,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,0,1,1,0,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,0,1,1,0,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,0,0,0,0,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,1,1,1,1,1,1,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,4,4,4,4,4,4,4,4,1,0,1,4,4,1],
            [1,4,4,1,0,1,1,1,1,1,1,1,1,1,1,0,1,4,4,1],
            [1,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,4,4,1],
            [1,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,4,1],
            [1,4,4,4,4,4,4,4,4,3,3,4,4,4,4,4,4,4,4,1], // 10,18 Entrance
            [1,1,1,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,1]
        ],
        portals: [
            { x: 9, y: 19, target: 'route2', targetX: 9, targetY: 2 },
            { x: 10, y: 19, target: 'route2', targetX: 10, targetY: 2 }
        ],
        npcs: [
            { x: 10, y: 3, text: ["吼！！！"], color: "#505050", sprite: "rattata", boss: true, bossId: 'onix' }
        ],
        signs: []
    }
};

const QUESTS = {
    q1: { id: 'q1', title: '捕捉练习', desc: '捕捉一只小拉达。', type: 'catch', targetId: 'rattata', count: 1, reward: { money: 200, item: 'potion', amount: 1 } },
    q2: { id: 'q2', title: '森林探险', desc: '捕捉一只绿毛虫。', type: 'catch', targetId: 'caterpie', count: 1, reward: { money: 300, item: 'ball', amount: 2 } },
    q3: { id: 'q3', title: 'BOSS挑战', desc: '打败地牢的 Boss。', type: 'boss', targetId: 'onix', count: 1, reward: { money: 1000, item: 'potion', amount: 5 } }
};

const SHOP_ITEMS = [
    { id: 'potion', price: 100 },
    { id: 'ball', price: 200 }
];

// --- Game State Management ---
const STATES = {
    OVERWORLD: 0,
    BATTLE: 1,
    DIALOGUE: 2,
    MENU: 3,
    SHOP: 4
};

// --- Input Handling ---
const Input = {
    keys: {},
    lastKeys: {},
    init() {
        window.addEventListener('keydown', e => {
            // Prevent default scrolling for arrow keys
            if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Enter"].indexOf(e.code) > -1) {
                e.preventDefault();
            }
            this.keys[e.key] = true;
        });
        window.addEventListener('keyup', e => this.keys[e.key] = false);
    },
    isDown(key) { return !!this.keys[key]; },
    isJustPressed(key) { return !!this.keys[key] && !this.lastKeys[key]; },
    update() { this.lastKeys = { ...this.keys }; }
};

// --- Game Data ---
const ITEMS = {
    potion: { name: '伤药', desc: '回复20HP', value: 20, type: 'heal' },
    ball: { name: '精灵球', desc: '尝试捕捉', value: 1.5, type: 'catch' }
};

const MOVES = {
    tackle: { name: '撞击', type: 'normal', pwr: 35, acc: 95, pp: 35 },
    scratch: { name: '抓', type: 'normal', pwr: 40, acc: 100, pp: 35 },
    growl: { name: '叫声', type: 'normal', pwr: 0, acc: 100, pp: 40, effect: 'stat', stat: 'atk', change: -1 },
    tailwhip: { name: '摇尾巴', type: 'normal', pwr: 0, acc: 100, pp: 30, effect: 'stat', stat: 'def', change: -1 },
    thundershock: { name: '电击', type: 'electric', pwr: 40, acc: 100, pp: 30, effect: 'status', status: 'par', chance: 0.3 },
    ember: { name: '火花', type: 'fire', pwr: 40, acc: 100, pp: 25, effect: 'status', status: 'brn', chance: 0.1 },
    vinewhip: { name: '藤鞭', type: 'grass', pwr: 45, acc: 100, pp: 25 },
    gust: { name: '起风', type: 'flying', pwr: 40, acc: 100, pp: 35 },
    poisonsting: { name: '毒针', type: 'poison', pwr: 15, acc: 100, pp: 35, effect: 'status', status: 'psn', chance: 0.3 },
    stringshot: { name: '吐丝', type: 'bug', pwr: 0, acc: 95, pp: 40, effect: 'stat', stat: 'spd', change: -1 },
    screech: { name: '刺耳声', type: 'normal', pwr: 0, acc: 85, pp: 40, effect: 'stat', stat: 'def', change: -2 },
    rockthrow: { name: '落石', type: 'rock', pwr: 50, acc: 90, pp: 15 }
};

const MONSTERS = {
    pikachu: { name: '皮卡丘', type: 'electric', hp: 35, atk: 55, def: 40, spd: 90, moves: ['thundershock', 'growl', 'tailwhip'], exp: 112 },
    rattata: { name: '小拉达', type: 'normal', hp: 30, atk: 56, def: 35, spd: 72, moves: ['tackle', 'tailwhip'], exp: 51 },
    pidgey: { name: '波波', type: 'flying', hp: 40, atk: 45, def: 40, spd: 56, moves: ['gust'], exp: 50 },
    caterpie: { name: '绿毛虫', type: 'bug', hp: 45, atk: 30, def: 35, spd: 45, moves: ['tackle', 'stringshot'], exp: 39 },
    onix: { name: '大岩蛇', type: 'rock', hp: 35, atk: 45, def: 160, spd: 70, moves: ['tackle', 'screech', 'rockthrow'], exp: 108 }
};

const LEVEL_RATE = (level) => Math.pow(level, 3);

function createPokemon(id, level) {
    const base = MONSTERS[id];
    const hp = Math.floor((2 * base.hp * level) / 100 + level + 10);
    return {
        id: id,
        name: base.name,
        type: base.type,
        level: level,
        maxHp: hp,
        hp: hp,
        atk: Math.floor((2 * base.atk * level) / 100 + 5),
        def: Math.floor((2 * base.def * level) / 100 + 5),
        spd: Math.floor((2 * base.spd * level) / 100 + 5),
        moves: base.moves.slice(0, 4)
            .map(m => MOVES[m] ? ({ ...MOVES[m], ppLeft: MOVES[m].pp }) : null)
            .filter(Boolean),
        exp: LEVEL_RATE(level),
        nextExp: LEVEL_RATE(level + 1),
        status: null
    };
}

// --- Classes ---

class Entity {
    constructor(x, y, isFollower = false) {
        this.gridX = x;
        this.gridY = y;
        this.x = x * TILE_SIZE;
        this.y = y * TILE_SIZE;
        this.targetX = this.x;
        this.targetY = this.y;
        this.isMoving = false;
        this.direction = 0; // 0: Down, 1: Up, 2: Left, 3: Right
        this.isFollower = isFollower;
    }

    update() {
        if (this.isMoving) {
            if (this.x < this.targetX) this.x += MOVE_SPEED;
            if (this.x > this.targetX) this.x -= MOVE_SPEED;
            if (this.y < this.targetY) this.y += MOVE_SPEED;
            if (this.y > this.targetY) this.y -= MOVE_SPEED;

            if (Math.abs(this.x - this.targetX) < MOVE_SPEED && Math.abs(this.y - this.targetY) < MOVE_SPEED) {
                this.x = this.targetX;
                this.y = this.targetY;
                this.gridX = Math.round(this.x / TILE_SIZE);
                this.gridY = Math.round(this.y / TILE_SIZE);
                this.isMoving = false;
            }
        }
    }

    tryMove(dx, dy, map) {
        if (this.isMoving) return false;

        const nextGridX = this.gridX + dx;
        const nextGridY = this.gridY + dy;

        // Map Boundaries
        if (nextGridY < 0 || nextGridY >= map.height || nextGridX < 0 || nextGridX >= map.width) return false;
        
        // Wall Collision
        const tile = map.data[nextGridY][nextGridX];
        if (tile === TILE.WALL || tile === TILE.SIGN) return false;

        // NPC Collision
        if (map.npcs.some(npc => npc.x === nextGridX && npc.y === nextGridY)) return false;

        this.targetX = nextGridX * TILE_SIZE;
        this.targetY = nextGridY * TILE_SIZE;
        this.isMoving = true;
        
        if (dy > 0) this.direction = 0;
        if (dy < 0) this.direction = 1;
        if (dx < 0) this.direction = 2;
        if (dx > 0) this.direction = 3;

        return true;
    }
}

class BattleSystem {
    constructor(game, onExit) {
        this.game = game;
        this.onExit = onExit;
        this.active = false;
        this.turn = 0; // 0:Menu, 1:Moves, 2:Bag, 3:Target, 4:Execute, 5:End
        this.log = "";
        this.playerPoke = null;
        this.enemyPoke = null;
        this.menuIndex = 0;
        this.fightIndex = 0;
        this.bagIndex = 0;
        this.flash = 0;
        this.isBoss = false;
    }

    start(enemy) {
        this.active = true;
        this.isBoss = false;
        this.turn = 0;
        this.playerPoke = this.game.player.team[0];
        this.enemyPoke = enemy;
        this.log = `野生的 ${enemy.name} 出现了!`;
        this.menuIndex = 0;
    }

    update() {
        if (this.turn === 4 || this.turn === 5) return;

        if (this.turn === 0) { // Main Menu
            if (Input.isJustPressed(KEYS.RIGHT)) this.menuIndex = Math.min(this.menuIndex + 1, 3);
            if (Input.isJustPressed(KEYS.LEFT)) this.menuIndex = Math.max(this.menuIndex - 1, 0);
            if (Input.isJustPressed(KEYS.DOWN)) this.menuIndex = Math.min(this.menuIndex + 2, 3);
            if (Input.isJustPressed(KEYS.UP)) this.menuIndex = Math.max(this.menuIndex - 2, 0);
            
            if (Input.isJustPressed(KEYS.A)) {
                if (this.menuIndex === 0) { this.turn = 1; this.fightIndex = 0; }
                else if (this.menuIndex === 1) { this.turn = 2; this.bagIndex = 0; }
                else if (this.menuIndex === 2) { this.log = "还不能换人!"; }
                else { // Run
                    if (Math.random() > 0.5 || this.playerPoke.spd > this.enemyPoke.spd) {
                         this.log = "成功逃跑!";
                         this.turn = 5;
                         setTimeout(() => this.exitBattle(), 1000);
                    } else {
                         this.log = "无法逃跑!";
                         this.executeTurn(null);
                    }
                }
            }
        } 
        else if (this.turn === 1) { // Fight Menu
            if (Input.isJustPressed(KEYS.DOWN)) this.fightIndex = Math.min(this.fightIndex + 1, this.playerPoke.moves.length - 1);
            if (Input.isJustPressed(KEYS.UP)) this.fightIndex = Math.max(this.fightIndex - 1, 0);
            if (Input.isJustPressed(KEYS.B)) this.turn = 0;
            if (Input.isJustPressed(KEYS.A)) {
                const move = this.playerPoke.moves[this.fightIndex];
                if (move.ppLeft > 0) {
                    this.executeTurn(move);
                } else {
                    this.log = "PP不足!";
                }
            }
        }
        else if (this.turn === 2) { // Bag Menu
            const items = Object.keys(this.game.player.bag);
            if (items.length === 0) {
                if (Input.isJustPressed(KEYS.B)) this.turn = 0;
                return;
            }
            if (Input.isJustPressed(KEYS.DOWN)) this.bagIndex = Math.min(this.bagIndex + 1, items.length - 1);
            if (Input.isJustPressed(KEYS.UP)) this.bagIndex = Math.max(this.bagIndex - 1, 0);
            if (Input.isJustPressed(KEYS.B)) this.turn = 0;
            if (Input.isJustPressed(KEYS.A)) {
                const itemId = items[this.bagIndex];
                this.useItem(itemId);
            }
        }
    }

    useItem(itemId) {
        const item = ITEMS[itemId];
        if (this.game.player.bag[itemId] <= 0) return;

        this.game.player.bag[itemId]--;
        if (this.game.player.bag[itemId] <= 0) delete this.game.player.bag[itemId];

        this.turn = 4;
        this.log = `使用了 ${item.name}!`;

        setTimeout(() => {
            if (item.type === 'heal') {
                const oldHp = this.playerPoke.hp;
                this.playerPoke.hp = Math.min(this.playerPoke.maxHp, this.playerPoke.hp + item.value);
                this.log = `回复了 ${this.playerPoke.hp - oldHp} 点HP!`;
                setTimeout(() => this.executeTurn(null), 1000);
            } else if (item.type === 'catch') {
                this.tryCatch(item.value);
            }
        }, 1000);
    }

    tryCatch(rateMod) {
        const hpPct = this.enemyPoke.hp / this.enemyPoke.maxHp;
        const statusBonus = this.enemyPoke.status ? 1.5 : 1;
        const chance = ((1 - hpPct) * 0.5 + 0.1) * rateMod * statusBonus;
        
        let shakes = 0;
        const interval = setInterval(() => {
            shakes++;
            this.log = `摇晃... (${shakes})`;
            if (Math.random() > chance && shakes < 3) {
                clearInterval(interval);
                this.log = "糟糕! 挣脱了!";
                setTimeout(() => this.executeTurn(null), 1500);
            } else if (shakes === 3) {
                clearInterval(interval);
                this.log = `收服了 ${this.enemyPoke.name}!`;
                this.game.player.team.push(this.enemyPoke);
                this.game.checkQuest(this.enemyPoke);
                setTimeout(() => this.exitBattle(true), 1500);
            }
        }, 800);
    }

    executeTurn(playerMove) {
        this.turn = 4;
        const max = (a,b)=>a>b?a:b;
        const enemyMove = this.enemyPoke.moves[Math.floor(Math.random() * this.enemyPoke.moves.length)];
        let first = this.playerPoke;
        let second = this.enemyPoke;
        let move1 = playerMove;
        let move2 = enemyMove;

        if (!playerMove) {
            first = this.enemyPoke;
            second = this.playerPoke;
            move1 = enemyMove;
            move2 = null;
        } else if (this.playerPoke.spd < this.enemyPoke.spd) {
             first = this.enemyPoke;
             second = this.playerPoke;
             move1 = enemyMove;
             move2 = playerMove;
        }

        const applyPreMoveStatus = (attacker) => {
            if (!attacker.status) return { canAct: true, msg: null };
            if (attacker.status === 'par') {
                if (Math.random() < 0.25) return { canAct: false, msg: `${attacker.name} 麻痹了! 动不了!` };
            }
            return { canAct: true, msg: null };
        };

        const applyStatusEndTurn = (poke) => {
            if (!poke.status || poke.hp <= 0) return null;
            if (poke.status === 'psn') {
                const dmg = max(1, Math.floor(poke.maxHp / 8));
                poke.hp = max(0, poke.hp - dmg);
                return `${poke.name} 因中毒受到了伤害!`;
            }
            if (poke.status === 'brn') {
                const dmg = max(1, Math.floor(poke.maxHp / 16));
                poke.hp = max(0, poke.hp - dmg);
                return `${poke.name} 被灼伤了!`;
            }
            return null;
        };

        const runMove = (attacker, defender, move, next) => {
            if (!move) { next(); return; }
            if (attacker.hp <= 0) { next(); return; }

            const pre = applyPreMoveStatus(attacker);
            if (!pre.canAct) {
                this.log = pre.msg;
                setTimeout(next, 900);
                return;
            }

            this.log = `${attacker.name} 使用 ${move.name}!`;
            if (move.ppLeft !== undefined) move.ppLeft--;

            setTimeout(() => {
                if (Math.random() * 100 > move.acc) {
                    this.log = "但是没打中!";
                    setTimeout(next, 1000);
                    return;
                }

                if (move.pwr > 0) {
                    const atkStat = attacker.status === 'brn' ? Math.max(1, Math.floor(attacker.atk * 0.5)) : attacker.atk;
                    let dmg = Math.floor((((2 * attacker.level / 5 + 2) * move.pwr * (atkStat / defender.def)) / 50) + 2);
                    if (Math.random() < 0.0625) { dmg *= 1.5; this.log += " 击中要害!"; }
                    defender.hp = Math.max(0, defender.hp - dmg);
                    this.flash = 10;
                } else if (move.effect === 'stat') {
                    this.log = `${defender.name} 的属性下降了!`;
                    defender[move.stat] = Math.max(1, Math.floor(defender[move.stat] * 0.8));
                } else if (move.effect === 'status') {
                    if (!defender.status && Math.random() < move.chance) {
                         defender.status = move.status;
                         if (move.status === 'par') defender.spd = Math.max(1, Math.floor(defender.spd * 0.5));
                         this.log = `${defender.name} 陷入了异常状态!`;
                    }
                }

                if (defender.hp <= 0) {
                    this.log = `${defender.name} 倒下了!`;
                    if (defender === this.enemyPoke) {
                        setTimeout(() => this.gainExp(), 1000);
                    } else {
                        setTimeout(() => {
                            this.log = "眼前一黑...";
                            setTimeout(() => this.exitBattle(), 1000);
                        }, 1000);
                    }
                } else {
                    setTimeout(next, 1000);
                }
            }, 800);
        };

        runMove(first, second, move1, () => {
             runMove(second, first, move2, () => {
                 // End-of-turn status damage (poison/burn)
                 const msgs = [applyStatusEndTurn(this.playerPoke), applyStatusEndTurn(this.enemyPoke)].filter(Boolean);
                 if (msgs.length) {
                     this.log = msgs[0];
                     if (this.playerPoke.hp <= 0) {
                         setTimeout(() => { this.log = '眼前一黑...'; setTimeout(() => this.exitBattle(), 900); }, 900);
                         return;
                     }
                     if (this.enemyPoke.hp <= 0) {
                         setTimeout(() => this.gainExp(), 900);
                         return;
                     }
                     setTimeout(() => {
                         this.turn = 0;
                         this.log = '要做什么?';
                     }, 900);
                     return;
                 }
                 this.turn = 0;
                 this.log = '要做什么?';
             });
        });
    }

    gainExp() {
        const exp = Math.floor(this.enemyPoke.exp * this.enemyPoke.level / 7);
        const money = Math.max(10, Math.floor(this.enemyPoke.level * 25 + this.enemyPoke.exp / 10));
        this.game.player.money = (this.game.player.money || 0) + money;
        this.log = `获得了 ${exp} 点经验值! 获得了 ¥${money}!`;
        this.playerPoke.exp += exp;
        
        setTimeout(() => {
            if (this.playerPoke.exp >= this.playerPoke.nextExp) {
                this.playerPoke.level++;
                this.playerPoke.nextExp = LEVEL_RATE(this.playerPoke.level + 1);
                const grow = Math.floor(Math.random() * 3) + 1;
                this.playerPoke.maxHp += grow;
                this.playerPoke.hp += grow;
                this.playerPoke.atk += 1;
                this.playerPoke.def += 1;
                this.playerPoke.spd += 1;
                this.log = `升级到了 Lv${this.playerPoke.level}!`;
            }
            setTimeout(() => this.exitBattle(true), 1500);
        }, 1000);
    }

    exitBattle(won = false) { this.active = false; this.onExit(won); }

    draw(ctx) {
        ctx.fillStyle = PALETTE.white;
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        if (this.flash > 0) {
            ctx.fillStyle = this.flash % 2 === 0 ? "#FFF" : "#000";
            ctx.fillRect(0,0, SCREEN_WIDTH, SCREEN_HEIGHT);
            this.flash--;
            return;
        }

        this.drawStatus(ctx, 10, 10, this.enemyPoke);
        // Basic Sprites Draw
        if (this.enemyPoke.id === 'rattata') Sprites.rattata(ctx, 100, 10);
        else { // Fallback square for others if not defined
            ctx.fillStyle = "#A040A0";
            ctx.fillRect(100, 20, 40, 30);
        }

        Sprites.pikachu_back(ctx, 10, 60);
        this.drawStatus(ctx, 80, 70, this.playerPoke, true);
        
        ctx.fillStyle = PALETTE.black;
        ctx.fillRect(0, 104, SCREEN_WIDTH, 40);
        ctx.fillStyle = PALETTE.white;
        ctx.fillRect(2, 106, SCREEN_WIDTH-4, 36);
        ctx.fillStyle = PALETTE.black;
        ctx.font = "10px 'Courier New'";
        
        if (this.turn === 0) {
            ctx.fillText(this.log || "要做什么?", 10, 120);
            ctx.fillRect(80, 104, 80, 40);
            ctx.fillStyle = PALETTE.white;
            ctx.fillRect(81, 105, 78, 38);
            ctx.fillStyle = PALETTE.black;
            
            const opts = ["战斗", "背包", "精灵", "逃跑"];
            ctx.fillText(opts[0], 95, 118);
            ctx.fillText(opts[1], 135, 118);
            ctx.fillText(opts[2], 95, 132);
            ctx.fillText(opts[3], 135, 132);
            
            const cx = this.menuIndex % 2 === 0 ? 88 : 128;
            const cy = this.menuIndex < 2 ? 118 : 132;
            ctx.fillText(">", cx, cy);

        } else if (this.turn === 1) { // Moves
             this.playerPoke.moves.forEach((m, i) => {
                 ctx.fillText(`${m.name}`, 20, 115 + i * 10);
             });
             ctx.fillText(">", 10, 115 + (this.fightIndex * 10));
             const move = this.playerPoke.moves[this.fightIndex];
             ctx.fillText(`PP ${move.ppLeft}/${move.pp}`, 100, 120);
             ctx.fillText(`Type/${move.type}`, 100, 130);
        } else if (this.turn === 2) { // Bag
             const items = Object.keys(this.game.player.bag);
             if (items.length === 0) ctx.fillText("背包是空的!", 10, 120);
             else {
                 items.forEach((id, i) => {
                     const item = ITEMS[id];
                     ctx.fillText(`${item.name} x${this.game.player.bag[id]}`, 20, 115 + i * 10);
                 });
                 ctx.fillText(">", 10, 115 + (this.bagIndex * 10));
             }
        } else {
             ctx.fillText(this.log, 10, 120);
        }
    }

    drawStatus(ctx, x, y, poke, showNum) {
        ctx.fillStyle = PALETTE.black;
        ctx.fillText(poke.name, x, y);
        ctx.fillText(":L" + poke.level, x + 50, y);
        if (poke.status) ctx.fillText(poke.status.toUpperCase(), x + 70, y);
        
        ctx.strokeRect(x, y + 5, 60, 4);
        const pct = poke.hp / poke.maxHp;
        ctx.fillStyle = pct > 0.5 ? "#50C050" : pct > 0.2 ? "#F0C030" : "#F04040";
        ctx.fillRect(x + 1, y + 6, Math.max(0, 58 * pct), 2);
        
        if (showNum) { 
             ctx.fillStyle = PALETTE.black; 
             ctx.fillText(`${poke.hp}/${poke.maxHp}`, x + 20, y + 18);
             ctx.fillStyle = "#4040FF";
             const expPct = (poke.exp - LEVEL_RATE(poke.level)) / (poke.nextExp - LEVEL_RATE(poke.level));
             ctx.fillRect(x, y + 20, 60 * Math.max(0, expPct), 2);
        }
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.ctx.imageSmoothingEnabled = false;
        Input.init();

        // State
        this.currentMapId = 'town';
        this.currentMap = MAPS['town'];
        
        this.player = new Entity(10, 10);
        this.player.team = [createPokemon('pikachu', 5)];
        this.player.bag = { potion: 1 };
        this.player.money = 500;
        this.player.quests = { active: [], completed: [] }; // Stores quest IDs

        this.pikachu = new Entity(10, 11, true);
        this.pikachu.direction = 1; 

        this.gameState = STATES.OVERWORLD;
        this.battle = new BattleSystem(this, (won) => { 
            this.gameState = STATES.OVERWORLD; 
            if (won && this.battle.isBoss) {
                this.player.quests.bossDefeated = true;
                this.showDialogue(["BOSS被击败了!", "任务进度已更新。"]);
            }
        });

        // Dialogue
        this.dialogueQueue = [];
        this.currentText = "";
        this.targetText = "";
        this.charIndex = 0;
        this.textSpeed = 1;
        this.textTimer = 0;

        // Menu
        this.menuOptions = ["队伍", "背包", "保存", "关闭"];
        this.menuIndex = 0;
        this.menuState = 0; // 0: Main, 1: Submenu

        // Camera
        this.camX = 0;
        this.camY = 0;
        
        this.frameCount = 0;

        // Load
        this.loadGame();

        this.lastTime = 0;
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    loadGame() {
        const save = localStorage.getItem('pokemon_canvas_save');
        if (save) {
            const data = JSON.parse(save);
            this.currentMapId = data.mapId;
            this.currentMap = MAPS[data.mapId];
            this.player.x = data.x;
            this.player.y = data.y;
            this.player.gridX = Math.round(data.x / TILE_SIZE);
            this.player.gridY = Math.round(data.y / TILE_SIZE);
            this.player.targetX = this.player.x;
            this.player.targetY = this.player.y;
            
            if (data.team) this.player.team = data.team;
            if (data.bag) this.player.bag = data.bag;
            if (data.quests) this.player.quests = data.quests;
            if (data.money) this.player.money = data.money;

            // Reset pikachu
            this.pikachu.x = this.player.x;
            this.pikachu.y = this.player.y + 16;
            this.pikachu.gridX = this.player.gridX;
            this.pikachu.gridY = this.player.gridY + 1;
            this.pikachu.targetX = this.pikachu.x;
            this.pikachu.targetY = this.pikachu.y;
        }
    }

    saveGame() {
        const data = {
            mapId: this.currentMapId,
            x: this.player.x,
            y: this.player.y,
            team: this.player.team,
            bag: this.player.bag,
            quests: this.player.quests,
            money: this.player.money
        };
        localStorage.setItem('pokemon_canvas_save', JSON.stringify(data));
        this.showDialogue(["游戏已保存。"]);
    }

    loop(timestamp) {
        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;
        this.frameCount++;
        this.update();
        this.draw();
        Input.update();
        requestAnimationFrame(this.loop);
    }

    update() {
        if (this.gameState === STATES.OVERWORLD) this.updateOverworld();
        else if (this.gameState === STATES.BATTLE) this.battle.update();
        else if (this.gameState === STATES.DIALOGUE) this.updateDialogue();
        else if (this.gameState === STATES.MENU) this.updateMenu();
    }

    updateOverworld() {
        // Open Menu
        if (Input.isJustPressed(KEYS.START)) {
            this.gameState = STATES.MENU;
            this.menuIndex = 0;
            this.menuState = 0;
            return;
        }

        // Interaction
        if (Input.isJustPressed(KEYS.A)) {
            this.checkInteraction();
            return;
        }

        // Movement
        let dx = 0, dy = 0;
        if (!this.player.isMoving) {
            if (Input.isDown(KEYS.UP)) dy = -1;
            else if (Input.isDown(KEYS.DOWN)) dy = 1;
            else if (Input.isDown(KEYS.LEFT)) dx = -1;
            else if (Input.isDown(KEYS.RIGHT)) dx = 1;

            if (dx !== 0 || dy !== 0) {
                const prevX = this.player.gridX;
                const prevY = this.player.gridY;
                
                if (this.player.tryMove(dx, dy, this.currentMap)) {
                    // Move Pikachu
                    this.pikachu.targetX = prevX * TILE_SIZE;
                    this.pikachu.targetY = prevY * TILE_SIZE;
                    this.pikachu.gridX = prevX;
                    this.pikachu.gridY = prevY;
                    this.pikachu.isMoving = true;
                    if (this.player.gridY < prevY) this.pikachu.direction = 1;
                    if (this.player.gridY > prevY) this.pikachu.direction = 0;
                    if (this.player.gridX < prevX) this.pikachu.direction = 2;
                    if (this.player.gridX > prevX) this.pikachu.direction = 3;

                    // Grass Check
                    if (this.currentMap.data[this.player.gridY][this.player.gridX] === TILE.GRASS) {
                        if (Math.random() < 0.15) this.triggerBattleNext = true;
                    }
                } else {
                    // Turn
                    if (dy > 0) this.player.direction = 0;
                    if (dy < 0) this.player.direction = 1;
                    if (dx < 0) this.player.direction = 2;
                    if (dx > 0) this.player.direction = 3;
                }
            }
        }

        this.player.update();
        this.pikachu.update();

        // Portal Check
        if (!this.player.isMoving && !this.triggerBattleNext) {
            const portal = this.currentMap.portals.find(p => p.x === this.player.gridX && p.y === this.player.gridY);
            if (portal) this.switchMap(portal);
        }

        if (this.triggerBattleNext && !this.player.isMoving) {
            // Only trigger encounter if we're still on encounter tile (grass)
            const onGrass = this.currentMap.data[this.player.gridY][this.player.gridX] === TILE.GRASS;
            if (!onGrass) { this.triggerBattleNext = false; }
            if (onGrass) {
                this.triggerBattleNext = false;
                this.gameState = STATES.BATTLE;
                const ids = ['rattata', 'pidgey', 'caterpie'];
                const id = ids[Math.floor(Math.random() * ids.length)];
                const lvl = Math.max(2, Math.floor(this.player.team[0].level - 1 + Math.random() * 3));
                this.battle.start(createPokemon(id, lvl));
            }
        }

        this.updateCamera();
    }

    updateCamera() {
        const targetCamX = this.player.x - SCREEN_WIDTH / 2 + TILE_SIZE / 2;
        const targetCamY = this.player.y - SCREEN_HEIGHT / 2 + TILE_SIZE / 2;
        this.camX += (targetCamX - this.camX) * 0.1;
        this.camY += (targetCamY - this.camY) * 0.1;
        this.camX = Math.max(0, Math.min(this.camX, (this.currentMap.width * TILE_SIZE) - SCREEN_WIDTH));
        this.camY = Math.max(0, Math.min(this.camY, (this.currentMap.height * TILE_SIZE) - SCREEN_HEIGHT));
    }

    switchMap(portal) {
        // prevent cross-map encounter carry-over
        this.triggerBattleNext = false;
        this.currentMapId = portal.target;
        this.currentMap = MAPS[portal.target];
        this.player.gridX = portal.targetX;
        this.player.gridY = portal.targetY;
        this.player.x = portal.targetX * TILE_SIZE;
        this.player.y = portal.targetY * TILE_SIZE;
        this.player.targetX = this.player.x;
        this.player.targetY = this.player.y;
        
        // Reset Pikachu nearby
        this.pikachu.gridX = portal.targetX;
        this.pikachu.gridY = portal.targetY; 
        this.pikachu.x = this.player.x;
        this.pikachu.y = this.player.y;
        this.pikachu.targetX = this.pikachu.x;
        this.pikachu.targetY = this.pikachu.y;
        this.pikachu.isMoving = false;
        
        this.camX = this.player.x - SCREEN_WIDTH/2; 
        this.camY = this.player.y - SCREEN_HEIGHT/2;
    }

    checkInteraction() {
        const dx = [0, 0, -1, 1][this.player.direction];
        const dy = [1, -1, 0, 0][this.player.direction];
        const tx = this.player.gridX + dx;
        const ty = this.player.gridY + dy;

        // Check NPCs
        const npc = this.currentMap.npcs.find(n => n.x === tx && n.y === ty);
        if (npc) {
            if (npc.boss) {
                if (this.player.quests.bossDefeated) {
                    this.showDialogue(["(大岩蛇已经倒下了)"]);
                } else {
                    this.showDialogue(["吼！！！"]);
                    setTimeout(() => {
                        this.gameState = STATES.BATTLE;
                        this.battle.isBoss = true;
                        this.battle.start(createPokemon('onix', 10));
                    }, 1000);
                }
                return;
            }
            if (npc.shop) {
                this.gameState = STATES.MENU; // Use Menu state for simplicity, or create custom SHOP state
                this.menuState = 4; // 4: Shop
                this.menuIndex = 0;
                return;
            }
            this.showDialogue(npc.text);
            return;
        }

        // Check Signs
        const sign = this.currentMap.signs.find(s => s.x === tx && s.y === ty);
        if (sign) {
            if (sign.text[0] === "公告板") {
                 const qId = Object.keys(QUESTS).find(id => !this.player.quests.completed.includes(id));
                 if (!qId) {
                     this.showDialogue(["所有任务已完成！"]);
                     return;
                 }
                 const q = QUESTS[qId];
                 const isActive = this.player.quests.active.includes(qId);
                 
                 if (isActive) {
                     let done = false;
                     if (q.type === 'catch') {
                         const count = this.player.team.filter(p => p.id === q.targetId).length;
                         if (count >= q.count) done = true;
                     } else if (q.type === 'boss') {
                         if (this.player.quests.bossDefeated) done = true;
                     }

                     if (done) {
                         this.player.quests.active = this.player.quests.active.filter(id => id !== qId);
                         this.player.quests.completed.push(qId);
                         this.player.money += q.reward.money;
                         if (q.reward.item) this.player.bag[q.reward.item] = (this.player.bag[q.reward.item] || 0) + q.reward.amount;
                         this.showDialogue([`完成任务: ${q.title}!`, `获得 ¥${q.reward.money}`]);
                     } else {
                         this.showDialogue([`进行中: ${q.title}`, q.desc]);
                     }
                 } else {
                     this.player.quests.active.push(qId);
                     this.showDialogue([`接受任务: ${q.title}`, q.desc]);
                 }
                 return;
            }
            this.showDialogue(sign.text);
            return;
        }
    }
    
    checkQuest(caughtPoke) {
        // Triggered inside BattleSystem
    }

    showDialogue(lines) {
        this.dialogueQueue = [...lines];
        this.gameState = STATES.DIALOGUE;
        this.nextDialogueLine();
    }

    nextDialogueLine() {
        if (this.dialogueQueue.length === 0) {
            this.gameState = STATES.OVERWORLD;
            return;
        }
        this.targetText = this.dialogueQueue.shift();
        this.currentText = "";
        this.charIndex = 0;
    }

    updateDialogue() {
        if (Input.isJustPressed(KEYS.B)) this.textSpeed = 3; // Speed up
        else this.textSpeed = 1;

        if (this.charIndex < this.targetText.length) {
            this.textTimer += this.textSpeed;
            if (this.textTimer >= 2) {
                this.charIndex++;
                this.currentText = this.targetText.substring(0, this.charIndex);
                this.textTimer = 0;
            }
        } else {
            // Wait for input
            if (Input.isJustPressed(KEYS.A)) {
                this.nextDialogueLine();
            }
        }
    }

    updateMenu() {
        if (this.menuState === 0) {
            if (Input.isJustPressed(KEYS.B)) {
                this.gameState = STATES.OVERWORLD;
            }
            if (Input.isJustPressed(KEYS.UP)) this.menuIndex = Math.max(0, this.menuIndex - 1);
            if (Input.isJustPressed(KEYS.DOWN)) this.menuIndex = Math.min(this.menuOptions.length - 1, this.menuIndex + 1);
            
            if (Input.isJustPressed(KEYS.A)) {
                const selection = this.menuOptions[this.menuIndex];
                if (selection === "关闭") this.gameState = STATES.OVERWORLD;
                else if (selection === "保存") {
                    this.saveGame();
                }
                else if (selection === "队伍") {
                    this.menuState = 1; // Show Team
                }
                else if (selection === "背包") {
                    this.menuState = 2; // Show Bag
                }
            }
        } else if (this.menuState === 4) { // Shop
             if (Input.isJustPressed(KEYS.B)) this.gameState = STATES.OVERWORLD;
             if (Input.isJustPressed(KEYS.UP)) this.menuIndex = Math.max(0, this.menuIndex - 1);
             if (Input.isJustPressed(KEYS.DOWN)) this.menuIndex = Math.min(SHOP_ITEMS.length - 1, this.menuIndex + 1);
             
             if (Input.isJustPressed(KEYS.A)) {
                 const itemData = SHOP_ITEMS[this.menuIndex];
                 if (this.player.money >= itemData.price) {
                     this.player.money -= itemData.price;
                     this.player.bag[itemData.id] = (this.player.bag[itemData.id] || 0) + 1;
                     // Optional: Feedback sound or visual
                 }
             }
        } else {
             if (Input.isJustPressed(KEYS.B)) this.menuState = 0;
        }
    }

    draw() {
        this.ctx.fillStyle = PALETTE.black;
        this.ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

        if (this.gameState === STATES.BATTLE) {
            this.battle.draw(this.ctx);
            return;
        }

        this.ctx.save();
        this.ctx.translate(-Math.floor(this.camX), -Math.floor(this.camY));

        // Map
        const map = this.currentMap;
        for (let y = 0; y < map.height; y++) {
            for (let x = 0; x < map.width; x++) {
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                if (px < this.camX - TILE_SIZE || px > this.camX + SCREEN_WIDTH ||
                    py < this.camY - TILE_SIZE || py > this.camY + SCREEN_HEIGHT) continue;
                
                const t = map.data[y][x];

                // Prefer CC0 tiles if loaded; fall back to procedural sprites.
                const drew = Assets.loaded && Assets.drawTile(this.ctx, t, px, py);
                if (drew) continue;

                if (t === TILE.WALL) Sprites.wall(this.ctx, px, py);
                else if (t === TILE.GRASS) {
                    this.ctx.fillStyle = PALETTE.white;
                    this.ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    Sprites.grass(this.ctx, px, py);
                }
                else if (t === TILE.FLOOR) Sprites.floor(this.ctx, px, py);
                else if (t === TILE.DOOR) Sprites.door(this.ctx, px, py);
                else if (t === TILE.SIGN) {
                    this.ctx.fillStyle = PALETTE.white;
                    this.ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    Sprites.sign(this.ctx, px, py);
                }
                else {
                    this.ctx.fillStyle = PALETTE.white;
                    this.ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        // Entities & NPCs (Z-Sorted)
        const renderList = [];
        
        // Player
        renderList.push({
            y: this.player.y,
            draw: () => Sprites.player.draw(this.ctx, this.player.x, this.player.y, this.frameCount, this.player.direction)
        });

        // Pikachu
        renderList.push({
            y: this.pikachu.y,
            draw: () => Sprites.pikachu.draw(this.ctx, this.pikachu.x, this.pikachu.y, this.frameCount, this.pikachu.direction)
        });

        // NPCs
        map.npcs.forEach(n => {
            const spriteId = n.sprite || 'npc';
            const drawer = Sprites[spriteId] || Sprites.npc;
            renderList.push({
                y: n.y * TILE_SIZE,
                draw: () => drawer.draw(this.ctx, n.x * TILE_SIZE, n.y * TILE_SIZE, n.color)
            });
        });

        renderList.sort((a, b) => a.y - b.y);
        renderList.forEach(r => r.draw());

        this.ctx.restore();

        // UI Layer
        if (this.gameState === STATES.DIALOGUE) this.drawDialogue();
        if (this.gameState === STATES.MENU) this.drawMenu();
    }

    drawDialogue() {
        this.ctx.fillStyle = PALETTE.black;
        this.ctx.fillRect(0, 104, SCREEN_WIDTH, 40);
        this.ctx.fillStyle = PALETTE.white;
        this.ctx.fillRect(2, 106, SCREEN_WIDTH-4, 36);
        this.ctx.fillStyle = PALETTE.black;
        this.ctx.font = "10px 'Courier New'";
        this.ctx.fillText(this.currentText, 10, 120);
        
        if (this.charIndex >= this.targetText.length) {
            // Blink arrow
            if (Math.floor(Date.now() / 500) % 2 === 0) {
                 this.ctx.fillText("▼", 145, 135);
            }
        }
    }

    drawMenu() {
        if (this.menuState === 0) {
            const boxW = 80;
            const boxH = this.menuOptions.length * 12 + 25;
            const startX = SCREEN_WIDTH - boxW - 2;
            const startY = 2;

            this.ctx.fillStyle = PALETTE.white;
            this.ctx.fillRect(startX, startY, boxW, boxH);
            this.ctx.strokeStyle = PALETTE.black;
            this.ctx.strokeRect(startX, startY, boxW, boxH);
            
            this.ctx.fillStyle = PALETTE.black;
            this.ctx.font = "10px 'Courier New'";
            
            this.menuOptions.forEach((opt, i) => {
                this.ctx.fillText(opt, startX + 15, startY + 12 + (i * 12));
            });

            this.ctx.fillText(">", startX + 5, startY + 12 + (this.menuIndex * 12));
            
            // Draw Money
            this.ctx.fillStyle = "#306850";
            this.ctx.fillText(`¥${this.player.money}`, startX + 5, startY + boxH - 5);
        } else if (this.menuState === 1) { // Team
            this.ctx.fillStyle = PALETTE.white;
            this.ctx.fillRect(10, 10, 140, 120);
            this.ctx.strokeRect(10, 10, 140, 120);
            this.ctx.fillStyle = PALETTE.black;
            this.ctx.fillText("队伍 (按X返回)", 15, 25);
            
            this.player.team.forEach((poke, i) => {
                 this.ctx.fillText(`${poke.name} Lv${poke.level} ${poke.hp}/${poke.maxHp}`, 15, 40 + i * 15);
            });
        } else if (this.menuState === 2) { // Bag
            this.ctx.fillStyle = PALETTE.white;
            this.ctx.fillRect(10, 10, 140, 120);
            this.ctx.strokeRect(10, 10, 140, 120);
            this.ctx.fillStyle = PALETTE.black;
            this.ctx.fillText("背包 (按X返回)", 15, 25);
            
            const items = Object.keys(this.player.bag);
             if (items.length === 0) this.ctx.fillText("背包是空的", 15, 40);
             else {
                 items.forEach((id, i) => {
                     const item = ITEMS[id];
                     this.ctx.fillText(`${item.name} x${this.player.bag[id]}`, 15, 40 + i * 15);
                 });
             }
        } else if (this.menuState === 4) { // Shop
            this.ctx.fillStyle = PALETTE.white;
            this.ctx.fillRect(10, 10, 140, 120);
            this.ctx.strokeRect(10, 10, 140, 120);
            this.ctx.fillStyle = PALETTE.black;
            this.ctx.fillText("商店 (按X离开)", 15, 25);
            this.ctx.fillText(`¥${this.player.money}`, 100, 25);

            SHOP_ITEMS.forEach((itemData, i) => {
                const name = ITEMS[itemData.id].name;
                this.ctx.fillText(`${name}`, 25, 45 + i * 15);
                this.ctx.fillText(`¥${itemData.price}`, 100, 45 + i * 15);
                if (i === this.menuIndex) this.ctx.fillText(">", 15, 45 + i * 15);
            });
        }
    }
}

window.onload = async () => {
    // Show a simple loading screen while preloading CC0 tiles.
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = '#202020';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#e0f8cf';
    ctx.font = '10px monospace';
    ctx.fillText('Loading assets...', 30, 70);

    try { await Assets.preload(); } catch (e) { /* ignore, fallback sprites still work */ }
    window.__game = new Game();
};

</script>
</body>
</html>
